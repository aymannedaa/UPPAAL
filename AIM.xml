<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>///////////////////////////////////////////////////////
// Author: Ayman Elkadi
// Email: aymannedaa@gmail.com 
///////////////////////////////////////////////////////

// This file is released under the following MIT/X11 license:

//Copyright (c) 2014-2015 Aalto University

//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in
//all copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//THE SOFTWARE.

////////////////////////////////////////////////////////////////

// This model is based on the AIM protocol, a protocol developed at University of Texas at Austin by Kurt Dresner and Peter stone. 
// The protocol is published in a paper, found on this link: http://www.cs.utexas.edu/~aim/papers/JAIR08-dresner.pdf  

// Note that there was no collaboration between the authors of the AIM protocol and myself. I happened to find their
// protocol an interseting one to be modeled in UPPAAL SMC and to check whether the protocol results in collisions between vehicles
// crossing a 4-way cross intersection or not. The model is a best effort to implement the AIM protocol in UPPAAL and it should not be 
// used directly to infer certain properties about the AIM protocol.

///////////////////////////////////////////////////////
//
//                                                  N
//                                                  ^
//                                                  |
//                   | | | v^ | | |
//                   | | | v^ | | |
//                   | | | v^ | | |
//                   | | | v^ | | |
//                   | | | v^ | | |
//                   | | | v^ | | |
//                   | | | v^ | | |    
//   ----------------              ----------------  
//   ----------------              ----------------
//   ----------------              ----------------
//   &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
//   &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
//   ----------------              ----------------
//   ----------------              ----------------
//   ----------------              ----------------
//                   | | | v^ | | |
//                   | | | v^ | | |
//                   | | | v^ | | |
//   y               | | | v^ | | |
//   ^               | | | v^ | | |
//   |               | | | v^ | | |
//   .--&gt;x           | | | v^ | | |                
// (0,0)                     . . . &lt;-- spawn points for North road lanes   
//
//                                |&lt;-------------&gt;|                   
//                                   road_length                           
//                   |&lt;----------&gt;|  
//                intersection_length
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                                                                             N
//                                                                                             ^
//                                                                                             |
//
//                                             (spawn_point[]X,spawn_point[]Y)
//           
//            (positionUL[][0],positionUL[][1]) .______________._____________. (positionUR[][0],positionUR[][1])
//      ^                                       |                            |
//      .                                       |                            |    
//      .                                       |                            |
//      .                                       |                            |
//      .                                       |                            |
//      .                                       |                            |           
//      . vehicle_length                        |                            |           
//      .                                       |                            |
//      .                                       |                            |
//      .                                       |                            |           
//      .                                       |                            | 
//      .                                       |                            |
//      .                                       |                            |
//      .                                       |                            |           
//      .                                       |                            |    
//      v                                       .____________________________.
//            (positionLL[][0],positionLL[][1])                                 (positionLR[][0],positionLR[][1])                     
//        
//                                              &lt;............................&gt;                
//                                                     vehicle_width
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// global declarations.
const int no_of_lanes=1; // number of lanes in a single direction per road, could be set to 1,2, or 3
const int noofvehs=50; // maximum number of vehicles required in the simulation
const int spawn_time=28;// vehicles are spawned every 'spawn_time' time units. A single time unit is equal to 'step' seconds. 
                        // For example if a step = 0.02 seconds , and spawn_time= 14 time units, then one vehicle is spawned every 14*0.02 = 0.28 seconds  
const double step= 0.02;    // time step in seconds

//grid dimensions
const double lane_width=3.0;
const double intersection_length= no_of_lanes * lane_width * 2; //meters
const double road_length= 20.0; //(318.0-intersection_length)/2;  //meters //a road can either end at an intersection or start at one

const double Denter=(0.6666667) * road_length; //Distance at which vehicle starts to communicate with the intersection manager

const double speed_limit = 15.0;//Road speed limit in meters  
const double max_distance_to_stop_before_intersection = speed_limit * step; // a vehicle stopping at the intersection will stop at a distance(meters)
         
// max no of steps a vehicle needs to cross the intersection
const int max_noOfsteps=400;
const int max_nooftiles_occupied=30;//=(ceil(vehicle_length) + 2) * (ceil(vehicle_width) + 2); //setting an upper limit on the number of occupied tiles 
double dist_to_stop_before_int=2.0;

//messages
typedef int MSG_TYPE;
MSG_TYPE V2I_MSG_msgtype; /*message type 1:REQ, 2:CHANGE_REQ, 3:CANCEL and 4:DONE */
int [0,400] V2I_MSG_vehicle_id; /* vehicle identifier */ 
double V2I_MSG_arrival_time; //millisecond /* the time at which the vehicle is planning to arrive at when it reaches the intersection */
int [0, 13] V2I_MSG_arrival_lane;  /* the lane the vehicle will arrive at when it reaches the intersection */ // here its the spawn lane , as vehicle doesn't change lanes before arriving at the intersection
int [0,4] V2I_MSG_turn; /* vehicle will turn at this direction after reaching the intersection */
double  V2I_MSG_arrival_velocity; // micrometer per second /* the velocity at which the vehicle agrees to be traveling when it arrives at the intersection.*/
double  V2I_MSG_maximum_velocity; //millimeters per second /* the maximum velocity at which the vehicle can travel.*/
double  V2I_MSG_maximum_acceleration; //millimeters per second squared /* the maximum rate at which the vehicle can accelerate.*/
double  V2I_MSG_minimum_acceleration; /* the minimum rate at which the vehicle can accelerate (i.e. negative number representing maximum deceleration).*/
double  V2I_MSG_vehicle_length; //millimeter /* the length of the vehicle.*/
double  V2I_MSG_vehicle_width; //millimeter /* the width of the vehicle.*/
int     [0,400] V2I_MSG_reservation_id; /* an identifier for the reservation to be changed. */ //used in CHANGE_REQ, CANCEL and DONE

MSG_TYPE I2V_MSG_msgtype; // 1:CONFIRM,2:REJECT,3:ACK
int [0, 400] I2V_MSG_reservation_id;  /* a unique identifier for the reservation just created. */ // used in CONFIRM and ACK
double I2V_MSG_arrival_time; /* the absolute time at which the vehicle is expected to arrive. */
double I2V_MSG_early_error; /* the tolerable error (early) in arrival time for the vehicle. */
double I2V_MSG_late_error; /* the tolerable error (late) in arrival time for the vehicle. */
int [0, 13] I2V_MSG_arrival_lane; /* a unique identifier for the lane in which the vehicle should be when it arrives at the intersection. */
double I2V_MSG_arrival_velocity; /* the velocity at which the vehicle is expected to be traveling when it arrives at the intersection. */
double I2V_MSG_accelerations[2]; /* acceleration and duration of acceleration, after this duration if the vehicle is still in the intersection it should move with a const speed*/
bool I2V_MSG_stop_required; /* a boolean value indicating whether the vehicle must first come to a full stop before entering the intersection. */ //used in REJECT only

// global message fields used by the intersection manager
int [0, 400] I2V_reservation_id;
int [0, 13] I2V_arrival_lane;
double I2V_messagetype,I2V_arrival_time,I2V_early_error,I2V_late_error,I2V_arrival_velocity,I2V_accelerations[2];
bool I2V_stop_required;


// Used to check the content of the messages in the simulation
int TV2I_MSG_msgtype[noofvehs]; /*message type 1:REQ, 2:CHANGE_REQ, 3:CANCEL and 4:DONE */
int TV2I_MSG_vehicle_id[noofvehs]; /* vehicle identifier */ 
double TV2I_MSG_arrival_time[noofvehs]; //millisecond /* the time at which the vehicle is planning to arrive at when it reaches the intersection */
int TV2I_MSG_arrival_lane[noofvehs];  /* the lane the vehicle will arrive at when it reaches the intersection */ // here its the spawn lane , as vehicle doesn't change lanes before arriving at the intersection
int TV2I_MSG_turn[noofvehs]; /* vehicle will turn at this direction after reaching the intersection */
double  TV2I_MSG_arrival_velocity[noofvehs]; // micrometer per second /* the velocity at which the vehicle agrees to be traveling when it arrives at the intersection.*/
double  TV2I_MSG_maximum_velocity[noofvehs]; //millimeters per second /* the maximum velocity at which the vehicle can travel.*/
double TV2I_MSG_maximum_acceleration[noofvehs]; //millimeters per second squared /* the maximum rate at which the vehicle can accelerate.*/
double  TV2I_MSG_minimum_acceleration[noofvehs]; /* the minimum rate at which the vehicle can accelerate (i.e. negative number representing maximum deceleration).*/
double  TV2I_MSG_vehicle_length[noofvehs]; //millimeter /* the length of the vehicle.*/
double  TV2I_MSG_vehicle_width[noofvehs]; //millimeter /* the width of the vehicle.*/
int     TV2I_MSG_reservation_id[noofvehs]; /* an identifier for the reservation to be changed. */ //used in CHANGE_REQ, CANCEL and DONE

int TI2V_MSG_msgtype[noofvehs]; // 1:CONFIRM,2:REJECT,3:ACK
int TI2V_MSG_reservation_id[noofvehs];  /* a unique identifier for the reservation just created. */ // used in CONFIRM and ACK
double TI2V_MSG_arrival_time[noofvehs]; /* the absolute time at which the vehicle is expected to arrive. */
double TI2V_MSG_early_error[noofvehs]; /* the tolerable error (early) in arrival time for the vehicle. */
double TI2V_MSG_late_error[noofvehs]; /* the tolerable error (late) in arrival time for the vehicle. */
int TI2V_MSG_arrival_lane[noofvehs]; /* a unique identifier for the lane in which the vehicle should be when it arrives at the intersection. */
double TI2V_MSG_arrival_velocity[noofvehs]; /* the velocity at which the vehicle is expected to be traveling when it arrives at the intersection. */
double TI2V_MSG_accelerations[2][noofvehs]; /* acceleration and duration of acceleration, after this duration if the vehicle is still in the intersection it should move with a const speed*/
bool TI2V_MSG_stop_required[noofvehs]; /* a boolean value indicating whether the vehicle must first come to a full stop before entering the intersection. */ //used in REJECT only

double  OccTiles[noofvehs][max_noOfsteps][max_nooftiles_occupied];
double  tempOccTiles[max_noOfsteps][max_nooftiles_occupied];

//channels
broadcast chan I2V;
broadcast chan V2I;

int [0, 400] channel_id;// id of the vehicle using the channel
bool channel_busy=false;// boolean set of channel is being used by a vehicle, only one vehicle can use a channel at a time, the channel stays busy until the a vehicle has successfully send a message to the central manager and recieved a response from it.
bool Mood[noofvehs]; //0:optimistic,1:pessimistic

double vehicle_has_reservation[noofvehs];
int [0, 400] vehicle_reservation_id[noofvehs];
double scheduled_arrival_time_in_reservation[noofvehs];
int [0, 4] turn_dir[noofvehs];  // 1 left , 2 straight, 3 right
bool reservation_is_accepted;
double accprofile[noofvehs][2];
bool exitstate; // indicate whether a vehicle has crossed the intersection or not
int [0,1000] step_no;

int [0, 400] vehicleID; //unique ID for each vehicle spawned, given incrementaly starting from 1.
bool terminatedvehicleID[noofvehs];
int [0, 4] spawn_road[noofvehs]; //starting road ID =&gt; 0:North , 1:East , 2:South , 3:West
int [0, 13] spawn_lane[noofvehs]; //starting lane ID =&gt; we start counting lanes from North road then East then South then West 
                      //                    each road we start counting from the middle intersecting axes of the map
                      //                    we start by the first lane on the North road giving it a spawn_lane id of 0  
                     //                    and continue in an incremental order as shown below for the case of 3 lanes


//                                  8 7 6 | 0 1 2                                            
//                               11              11           
//                               10              10    
//                               9               9
//                               --              --
//                               3               3
//                               4               4
//                               5               5 
//                                 8 7 6 | 0 1 2                                              
//  



int [0, 4] dest_road[noofvehs]; // destination road ID =&gt; 0:North , 1:East , 2:South , 3:West
int [0, 13] dest_lane[noofvehs]; // destination lane ID
int [0, 4] current_road[noofvehs];
int [0, 13] current_lane[noofvehs];

const double PI=3.141592654;
                                                      
double spawn_pointX[noofvehs]; // x coordinates at which the middle front point of the vehicle is spawned at
double spawn_pointY[noofvehs]; // y coordinates at which the middle front point of the vehicle is spawned at

double positionUL[noofvehs][2]; // X([id][0]) and Y([id][1]) coordinates of the Upper Left corner point of the vehicle 
double positionUR[noofvehs][2]; // X([id][0]) and Y([id][1]) coordinates of the Upper Left corner point of the vehicle 
double positionLL[noofvehs][2]; // X([id][0]) and Y([id][1]) coordinates of the Upper Left corner point of the vehicle 
double positionLR[noofvehs][2]; // X([id][0]) and Y([id][1]) coordinates of the Upper Left corner point of the vehicle 
double positionLM[noofvehs][2]; //X([id][0]) and Y([id][1]) coordinates of the Lower Middle corner point of the vehicle
double positionUM[noofvehs][2];

double velocity[noofvehs]; // meters/sec
double acceleration[noofvehs]; // meters/sec^2
double distance[noofvehs]; // meters
double distance_to_intersection[noofvehs]; //meters
double distance_to_come_to_complete_stop[noofvehs]; //meters
double perpendicular_distance_to_end_of_journey[noofvehs]; //meters
double perpendicular_distance_to_end_of_journeyLL[noofvehs];
double perpendicular_distance_to_end_of_journeyLR[noofvehs];
double total_distance_traveled[noofvehs];
int [0, 4] crossing_state[noofvehs]; // vehicle crossing states, 0:prior to crossing, 1:crossing, 2: after crossing
bool stopping_before_int[noofvehs]; 
double arrival_time[noofvehs];
double positionLM_internal_sim[2];
double orientation_internal_sim;

//turning variables
double orientation[noofvehs]; // measured from the x-axis in an anti-clockwise direction 
double steeringangle[noofvehs]; //measured from the orientation of the vehicle in an anti-clockwise direction
double final_orientation[noofvehs];
bool once[noofvehs];

int [0, 40] no_of_collisions; // counter for the total number of collisions
int [0, 40] no_of_collisions_on_intersection;// counter for the number of collisions happening within the intersection area
bool pilledup; // flag to signal vehicles piling up on any of the roads reaching the start of a road
int [0, 400] id_of_first_vehicle_pilling_up; 
int [0, 400] no_of_cleared_vehicles; // a counter for the number of vehicles which have finished their journey
int [0, 400] no_of_vehicles_crossed; // a counter for the number of vehicles which have crossed the intersection
double average_trip_delay; // for all vehicles which have finished their journey, the trip delay is the time taken by vehicle to finish its journey subtracted from the time it takes it to finish its journey if the vehicle didn't stop at the intersection(going with a constant speed_limit) 
double total_journey_time[noofvehs];

//variables for determining vehicle infront
int [0, 400] last_vehicle_on_spawn_lane_id[12]; //  for each lane we keep track of the last vehicle entering the lane at each time step   
int [0, 400] last_vehicle_on_dest_lane_id[12];
int [0, 400] vehicle_infront_id[noofvehs]; // id of the vehicle infront of this vehicle
double distance_to_vehicle_infront[noofvehs];


int [0, 400] reserved_vehicle_id_list[noofvehs+1000];// vehicles aleady having a reservation from the intersection manager will have their ids in this list
int [0, 1000] reserved_vehicle_id_list_size;

double arrival_time_list[noofvehs]; //list containing the arrival time of each vehicle to the intersection, this list is updated when vehicle sends messages to the intersection manager with new arrival times

const double safety_distance=3.0; //vertical safety distance to keep between vehicles on the road  

struct{
   int [0, 400] id1[noofvehs];
   int [0, 400] id2[noofvehs];
}collidedvehicles; // structure that stores the ids of collided vehicles so that we count a collision between 2 vehicles once

//vehicle characteristics 
// charactaristics matches the charactaristics of a small size vehicle having moderate performance
const double vehicle_length= 4.0; //meters
const double vehicle_width= 1.0; //meters
const double vehicle_maxAcceleration=3.25; //meters/s^2
const double vehicle_maxDeceleration=-39.0; //meters/s^2

int [0, 400] driver_sending_id;

//variables for intersection manager internal simulation
                // TODO: change the 'granularity' variable name as granularity means: The intersection is divided into an n Ã— n grid of reservation tiles, where n is the granularity. 
			    const double granularity=1.5; //This is the length and width of the reservation tiles in meters 

			    double area_length = intersection_length; // length of the area (in the y_internal_sim direction) that we want to create our tiles on
			    double area_width =intersection_length; // width of the area (in the x_internal_sim direction) that we want to create our tiles on
			    double distx=granularity; //granularity in x_internal_sim direction
			    double disty=granularity; //granularity in y_internal_sim direction
			   
                //safety
              //  double initx=road_length -1.0 ; // x_internal_sim coordinates of the lower left point of the intersection area 
			      double initx=road_length; // x_internal_sim coordinates of the lower left point of the intersection area 
             //  double inity=road_length -1.0 ; // y_internal_sim coordinates of the lower left point of the intersection area
                  double inity=road_length; // y_internal_sim coordinates of the lower left point of the intersection area			         

			     int [0, 1000] NoOfTiles; // total number of tiles that will cover the intersection area  
			     double Tile_length[1000];//[NoOfTiles+1];// tile length in y_internal_sim direction 
				 double Tile_width[1000]; // tile width in x_internal_sim direction 
				 double Tile_llx[1000]; // x_internal_sim coordinate of the lower-left point of the tile 
				 double Tile_lly[1000]; // y_internal_sim coordinate of the lower-left point of the tile   
                 bool isEdgeTile[1000];	
				       
                 const int edgetimeBuffer=40;//time steps ,this is the edge buffer 
                 const int internaltimeBuffer=15;// time steps, this is the time buffer

			     double positionUM_internal_sim[2]={0.0,0.0}; 
                 double positionLR_internal_sim[2]={0.0,0.0};  
                 double positionLL_internal_sim[2]={0.0,0.0}; 
                 double perpendicular_distance_to_end_of_journey_internal_sim;

                 double vehicle_length_internal=vehicle_length+ 1.0;
                 double vehicle_width_internal=vehicle_width+ 1.0;   

			
double positionLRx;
double positionLRy;

double positionLLx;
double positionLLy;

double positionULx;
double positionULy;

double positionURx;
double positionURy;
			    
double vert1x[4];// Array containing the x-coordinates of the  vehicle vertices.
double vert1y[4];// Array containing the y-coordinates of the  vehicle vertices.
double vert2x[4];// Array containing the x-coordinates of the tile vertices. UL,UR,LL and LR
double vert2y[4];

bool onetime=false;
int arrival_stepno_of_new_vehicle[noofvehs];

// dynamically created template
dynamic Vehicle(const int id); 

// a cast from double data type to integer data type function, as UPPAAL 4.1.19 doesn't have a cast function
int castDoubleToInt(double value){
	double i;
    int k=0;
	for(i=value;i&gt;=1;i=i-1){
	k++;
	}
	return k;
}

// choose the spawn lane based on the direction the vehicle wants to take, and set the destination road and lane
void chooseSpawnLane(int id,int dir){
// dir : 1 left , 2 straight, 3 right
turn_dir[id]=dir;

if(no_of_lanes==3){
if (spawn_road[id]==0){
if(dir ==1){
spawn_lane[id]=0;
spawn_pointX[id]=road_length+ 3.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=0;
dest_road[id]=3;
dest_lane[id]=9;
}else if(dir ==2){
spawn_lane[id]=1;
spawn_pointX[id]=road_length+ 4.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=0;
dest_road[id]=spawn_road[id];
dest_lane[id]=spawn_lane[id];
}else if(dir ==3){
spawn_lane[id]=2;
spawn_pointX[id]=road_length+ 5.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=0;
dest_road[id]=1;
dest_lane[id]=5;
}
}else if (spawn_road[id]==1){
if(dir ==1){
spawn_lane[id]=3;
spawn_pointX[id]=0;
spawn_pointY[id]=road_length+ 2.5 * (0.5 * intersection_length/no_of_lanes);
dest_road[id]=0;
dest_lane[id]=0;
}else if(dir ==2){
spawn_lane[id]=4;
spawn_pointX[id]=0;
spawn_pointY[id]=road_length+ 1.5 * (0.5 * intersection_length/no_of_lanes);
dest_road[id]=spawn_road[id];
dest_lane[id]=spawn_lane[id];
}else if(dir ==3){
spawn_lane[id]=5;
spawn_pointX[id]=0;
spawn_pointY[id]=road_length+ 0.5 * (0.5 * intersection_length/no_of_lanes);
dest_road[id]=2;
dest_lane[id]=8;
}
}else if (spawn_road[id]==2){
if(dir ==1){
spawn_lane[id]=6;
spawn_pointX[id]=road_length+ 2.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=2*road_length + intersection_length;
dest_road[id]=1;
dest_lane[id]=3;
}else if(dir ==2){
spawn_lane[id]=7;
spawn_pointX[id]=road_length+ 1.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=2*road_length + intersection_length;
dest_road[id]=spawn_road[id];
dest_lane[id]=spawn_lane[id];
}else if(dir ==3){
spawn_lane[id]=8;
spawn_pointX[id]=road_length+ 0.5 * (0.5 * intersection_length/no_of_lanes);
spawn_pointY[id]=2*road_length + intersection_length;
dest_road[id]=3;
dest_lane[id]=11;
}
}else if(spawn_road[id]==3){
if(dir ==1){
spawn_lane[id]=9;
spawn_pointX[id]=2*road_length + intersection_length;
spawn_pointY[id]=road_length+ 3.5 * (0.5 * intersection_length/no_of_lanes) ;
dest_road[id]=2;
dest_lane[id]=6;
}else if(dir ==2){
spawn_lane[id]=10;
spawn_pointX[id]= 2*road_length + intersection_length; 
spawn_pointY[id]= road_length+ 4.5 * (0.5 * intersection_length/no_of_lanes) ;
dest_road[id]=spawn_road[id];
dest_lane[id]=spawn_lane[id];
}else if(dir ==3){
spawn_lane[id]=11;
spawn_pointX[id]= 2*road_length + intersection_length; 
spawn_pointY[id]= road_length+ 5.5 * (0.5 * intersection_length/no_of_lanes) ;
dest_road[id]=0;
dest_lane[id]=2;
}
}

}else if(no_of_lanes==2){
// if number of lanes is 2 then vehicles going straight have to take the left lane, i.e. right lanes are only for right turns

if (spawn_road[id]==0){
if(dir ==1){
spawn_lane[id]=0;
spawn_pointX[id]=road_length+ 2.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=0;
dest_road[id]=3;
dest_lane[id]=6;
}else if(dir ==2){
spawn_lane[id]=0;
spawn_pointX[id]=road_length+ 2.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=0;
dest_road[id]=spawn_road[id];
dest_lane[id]=spawn_lane[id];
}else if(dir ==3){
spawn_lane[id]=1;
spawn_pointX[id]=road_length+ 3.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=0;
dest_road[id]=1;
dest_lane[id]=3;
}
}else if (spawn_road[id]==1){
if(dir ==1){
spawn_lane[id]=2;
spawn_pointX[id]=0;
spawn_pointY[id]=road_length+ 1.5 * (0.5 * intersection_length/no_of_lanes);
dest_road[id]=0;
dest_lane[id]=0;
}else if(dir ==2){
spawn_lane[id]=2;
spawn_pointX[id]=0;
spawn_pointY[id]=road_length+ 1.5 * (0.5 * intersection_length/no_of_lanes);
dest_road[id]=spawn_road[id];
dest_lane[id]=spawn_lane[id];
}else if(dir ==3){
spawn_lane[id]=3;
spawn_pointX[id]=0;
spawn_pointY[id]=road_length+ 0.5 * (0.5 * intersection_length/no_of_lanes);
dest_road[id]=2;
dest_lane[id]=5;
}
}else if (spawn_road[id]==2){
if(dir ==1){
spawn_lane[id]=4;
spawn_pointX[id]=road_length+ 1.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=2*road_length + intersection_length;
dest_road[id]=1;
dest_lane[id]=2;
}else if(dir ==2 ){
spawn_lane[id]=4;
spawn_pointX[id]=road_length+ 1.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=2*road_length + intersection_length;
dest_road[id]=spawn_road[id];
dest_lane[id]=spawn_lane[id];
}else if(dir ==3){
spawn_lane[id]=5;
spawn_pointX[id]=road_length+ 0.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=2*road_length + intersection_length;
dest_road[id]=3;
dest_lane[id]=7;
}
}else if(spawn_road[id]==3){
if(dir ==1){
spawn_lane[id]=6;
spawn_pointX[id]=2*road_length + intersection_length;
spawn_pointY[id]=road_length+ 2.5 * (0.5 * intersection_length/no_of_lanes) ;
dest_road[id]=2;
dest_lane[id]=4;
}else if(dir ==2){
spawn_lane[id]=6;
spawn_pointX[id]=2*road_length + intersection_length;
spawn_pointY[id]=road_length+ 2.5 * (0.5 * intersection_length/no_of_lanes) ;
dest_road[id]=spawn_road[id];
dest_lane[id]=spawn_lane[id];
}else if(dir ==3){
spawn_lane[id]=7;
spawn_pointX[id]=2*road_length + intersection_length;
spawn_pointY[id]=road_length+ 3.5 * (0.5 * intersection_length/no_of_lanes) ;
dest_road[id]=0;
dest_lane[id]=1;
}
}

}else if(no_of_lanes==1){
// all directions on a single road go through the same lane
spawn_lane[id]= spawn_road[id];

if (spawn_road[id]==0){
spawn_pointX[id]=road_length+ 1.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=0;
if(dir ==1)
dest_road[id]=3;
else if(dir ==2)
dest_road[id]=spawn_road[id];
else if(dir ==3)
dest_road[id]=1;
}else if (spawn_road[id]==1){
spawn_pointX[id]=0;
spawn_pointY[id]=road_length+ 0.5 * (0.5 * intersection_length/no_of_lanes);
if(dir ==1)
dest_road[id]=0;
else if(dir ==2)
dest_road[id]=spawn_road[id];
else if(dir ==3)
dest_road[id]=2;
}else if (spawn_road[id]==2){
spawn_pointX[id]=road_length+ 0.5 * (0.5 * intersection_length/no_of_lanes) ;
spawn_pointY[id]=2*road_length + intersection_length;
if(dir ==1)
dest_road[id]=1;
else if(dir ==2)
dest_road[id]=spawn_road[id];
else if(dir ==3)
dest_road[id]=3;
}else if(spawn_road[id]==3){
spawn_pointX[id]=2*road_length + intersection_length;
spawn_pointY[id]=road_length+ 1.5 * (0.5 * intersection_length/no_of_lanes) ;
if(dir ==1)
dest_road[id]=2;
else if(dir ==2)
dest_road[id]=spawn_road[id];
else if(dir ==3)
dest_road[id]=0;
}
dest_lane[id]=dest_road[id];
}

}

//set vehicle's initial state
void setVehInitialState(int id){

//initialize vehicle's velocity and acceleration
//vehicles are spawned with a constant velocity according to the road's speed limit 
velocity[id]=speed_limit; 
acceleration[id]=0.0; 

vehicle_infront_id[id]=last_vehicle_on_spawn_lane_id[spawn_lane[id]];    
last_vehicle_on_spawn_lane_id[spawn_lane[id]]=id;

distance_to_come_to_complete_stop[id]= - 0.5 * vehicle_maxDeceleration * (velocity[id]/vehicle_maxDeceleration) * (velocity[id]/vehicle_maxDeceleration); // d=vt-0.5at^2 , t=(v-u)/a where v=0  
//change spawn points to a lower point to prevent the spawn vehicle from hitting vehicle infront
if(spawn_road[id]==0){
positionUL[id][1] = spawn_pointY[id];
if(distance_to_come_to_complete_stop[id]&gt; positionLL[vehicle_infront_id[id]][1]- positionUL[id][1])
spawn_pointY[id]=positionLL[vehicle_infront_id[id]][1]- distance_to_come_to_complete_stop[id];
}else if(spawn_road[id]==1){
positionUL[id][0] = spawn_pointX[id];
if(distance_to_come_to_complete_stop[id]&gt; positionLL[vehicle_infront_id[id]][0]- positionUL[id][0])
spawn_pointX[id]=positionLL[vehicle_infront_id[id]][0]- distance_to_come_to_complete_stop[id];
}else if(spawn_road[id]==2){
positionUL[id][1] = spawn_pointY[id];
if(distance_to_come_to_complete_stop[id]&gt;  positionUL[id][1] - positionLL[vehicle_infront_id[id]][1])
spawn_pointY[id]=positionLL[vehicle_infront_id[id]][1] + distance_to_come_to_complete_stop[id];
}else if(spawn_road[id]==3){
positionUL[id][0] = spawn_pointX[id];
if(distance_to_come_to_complete_stop[id]&gt;  positionUL[id][0] - positionLL[vehicle_infront_id[id]][0])
spawn_pointX[id]=positionLL[vehicle_infront_id[id]][0] + distance_to_come_to_complete_stop[id];
}

//set vehicle's position at its spawn position at the start of the vehicle's movement
if(spawn_road[id]==0){
positionLM[id][0] = spawn_pointX[id];
positionLM[id][1] = spawn_pointY[id] - vehicle_length;
positionUL[id][0] = spawn_pointX[id] - vehicle_width/2;
positionUL[id][1] = spawn_pointY[id];
positionUR[id][0] = spawn_pointX[id] + vehicle_width/2;
positionUR[id][1] = spawn_pointY[id];
positionLL[id][0] = spawn_pointX[id] - vehicle_width/2;
positionLL[id][1] = spawn_pointY[id] - vehicle_length;
positionLR[id][0] = spawn_pointX[id] + vehicle_width/2;
positionLR[id][1] = spawn_pointY[id] - vehicle_length;
}else if(spawn_road[id]==1){
positionLM[id][0] = spawn_pointX[id] - vehicle_length;
positionLM[id][1] = spawn_pointY[id];
positionUL[id][0] = spawn_pointX[id];
positionUL[id][1] = spawn_pointY[id] + vehicle_width/2;
positionUR[id][0] = spawn_pointX[id];
positionUR[id][1] = spawn_pointY[id] - vehicle_width/2;
positionLL[id][0] = spawn_pointX[id] - vehicle_length;
positionLL[id][1] = spawn_pointY[id] + vehicle_width/2;
positionLR[id][0] = spawn_pointX[id] - vehicle_length;
positionLR[id][1] = spawn_pointY[id] - vehicle_width/2;
}else if(spawn_road[id]==2){
positionLM[id][0] = spawn_pointX[id];
positionLM[id][1] = spawn_pointY[id] + vehicle_length;
positionUL[id][0] = spawn_pointX[id] + vehicle_width/2;
positionUL[id][1] = spawn_pointY[id];
positionUR[id][0] = spawn_pointX[id] - vehicle_width/2;
positionUR[id][1] = spawn_pointY[id];
positionLL[id][0] = spawn_pointX[id] + vehicle_width/2;
positionLL[id][1] = spawn_pointY[id] + vehicle_length;
positionLR[id][0] = spawn_pointX[id] - vehicle_width/2;
positionLR[id][1] = spawn_pointY[id] + vehicle_length;
}else if(spawn_road[id]==3){
positionLM[id][0] = spawn_pointX[id] + vehicle_length;
positionLM[id][1] = spawn_pointY[id];
positionUL[id][0] = spawn_pointX[id];
positionUL[id][1] = spawn_pointY[id] - vehicle_width/2;
positionUR[id][0] = spawn_pointX[id];
positionUR[id][1] = spawn_pointY[id] + vehicle_width/2;
positionLL[id][0] = spawn_pointX[id]+ vehicle_length;
positionLL[id][1] = spawn_pointY[id] - vehicle_width/2;
positionLR[id][0] = spawn_pointX[id]+ vehicle_length;
positionLR[id][1] = spawn_pointY[id] + vehicle_width/2;
}

// set vehicle's current road and lane 
current_road[id]=spawn_road[id];
current_lane[id]=spawn_lane[id];

//set vehicle's orientation
if(spawn_road[id]==0)
orientation[id]=PI/2;
else if(spawn_road[id]==1)
orientation[id]=0.0; 
else if(spawn_road[id]==2)
orientation[id]=3*PI/2; 
else if(spawn_road[id]==3)
orientation[id]=PI; 

//mark vehicle's final orientation
if(dest_road[id]==0)
final_orientation[id]=PI/2;
else if(dest_road[id]==1)
final_orientation[id]=0.0; 
else if(dest_road[id]==2)
final_orientation[id]=3*PI/2; 
else if(dest_road[id]==3)
final_orientation[id]=PI;

}

//If the vehicle is moving with a lower speed that the speed limit , set it's acceleration to maximum value until reaching the speed limit 
void setVehicleAccelerationForNormalMode(int id){
if(velocity[id]&lt;speed_limit){
acceleration[id]=vehicle_maxAcceleration;
}
else acceleration[id]=0.0; // keep with constant speed
}

void setVehicleAccelerationForStoppingMode(int id){
if(velocity[id] &gt; 0.0){
acceleration[id]=vehicle_maxDeceleration;
}
else {acceleration[id]=0.0; velocity[id]=0.0;} // keep acceleration and velocity values to zero in order not to move backwards
}

/* estimate vehicle arrival time at the intersection when mood is optimistic */
double estimate_arrival_time_and_velocity_when_mood_is_optimistic(int ID){

double Arrival_velocity;
double va=speed_limit; // We will assume that turning vehicles as straight vehicles would like to arrive at the inersection boundaries at the speed_limit, this could be changed with setting Va to lower values for turning vehicles for example later

double vm=speed_limit; // vehicle max velocity is set to speed limit, so that the vehicle doesn't cross over the speed limit
double d;
double u;
double t;
double dist_when_uniform_accel_to_reach_va;
double ti;
double di;
double dk;
double tk;
double dj;
double tj;
double max_vel_reached;

d=distance_to_intersection[ID];
u=velocity[ID];

dist_when_uniform_accel_to_reach_va= ((va * va) - (u * u))/(2 * vehicle_maxAcceleration); // distance reached if we moved with uniform max acceleration until we reached the arrival velocity 
// Let's check if this distance is longer than the dist to the intersection, if it is then that means we estimate that the vehicle will be accelerating from now with max acc. and it won't be able to reach the arrival velocity required, but vehicle_maxAcceleration lower velocity
if(dist_when_uniform_accel_to_reach_va &gt; d){ 
Arrival_velocity= sqrt((u * u)+(2 * vehicle_maxAcceleration * d));
t=(Arrival_velocity - u)/vehicle_maxAcceleration;
}else{ 
// here we limited the choices of vehicle's trajectory to reach the intersection as follows: option 1: either the vehicle would accelerate with max acc. until it reached the max velocity and then stays with this velocity until it decelerates with max deceleration to reach the intersection at the required arrival velocity
// or option 2: the vehicle would not be able to reach the max velocity due to the short distance to the intersection so it accelerates to some velocity that is higher than the arrival velocity but lower than the max velocity and then directly decelerates with max decelration to reach the required arrival velocity (note we already checked in the previous step that the vehicle is able to reach the arrival velocity)       

ti = (vm - u)/vehicle_maxAcceleration; 
di= (vm * ti) - (0.5 * vehicle_maxAcceleration * ti * ti);
dk=((va * va) - (vm * vm))/(2 * vehicle_maxDeceleration);

if( d - di &gt; dk){ // option 1
tk = (va - vm)/(vehicle_maxDeceleration);
dj=d-di-dk;
tj=dj/vm;

t=ti+tj+tk;
Arrival_velocity=va;
}else{ // option 2
max_vel_reached=sqrt((d + ((u * u)/(2 * vehicle_maxAcceleration)) - ((va * va)/(2 * vehicle_maxDeceleration)))/((1/(2 * vehicle_maxAcceleration))-(1/(2* vehicle_maxDeceleration))));
t= ((max_vel_reached - u)/vehicle_maxAcceleration) + ((va - max_vel_reached)/vehicle_maxDeceleration);
Arrival_velocity=va;
}
}

arrival_time[ID]=t + total_journey_time[ID] + ID * spawn_time * step;//+ global_time_step * step;
return Arrival_velocity;

}

/* estimate vehicle arrival time at the intersection according to the vehicle's 'mood'  */
/*A vehicle has an 'optimistic mood' if it assumes it will arrive at the intersection in the minimum possible time. However, If a vehicle has to cancel its reservation as it wont be able to arrive on time due to being stuck behind a slower vehicle, it becomes pessimistic and stays in that mood until it finds itself no longer stuck behind a slower vehicle */
double estimate_arrival_time_and_velocity_to_intersection(int mood, int id) {

double arrive_vel;
if(mood==1){ // pessimistic
if(velocity[id]==0.0) arrival_time[id]=199.0; // infinity // TODO: make it a value that will be tedected by the intersection manager as infinity or don't send a message then
else
arrival_time[id]=distance_to_intersection[id]/velocity[id] + total_journey_time[id] + id * spawn_time * step;//+ global_time_step * step;
arrive_vel= velocity[id];
}else if(mood==0){ //optimistic
arrive_vel= estimate_arrival_time_and_velocity_when_mood_is_optimistic(id);
}
// due to limitations on the maximum allowed value of integer , casting to double on the intersection manager side could lead to value overflow 
if(arrival_time[id]&gt;199) //(199/0.02=9999 =&gt; max allowed integer value)
arrival_time[id]=199.0;

return arrive_vel;
}


void createV2IMsg(int msgtype, int vehicle_id, double arrival_Time, int arrival_lane, int turn, double arrival_velocity, double maximum_velocity, double maximum_acceleration, double minimum_acceleration, double vehicle_length, double vehicle_width,int reservation_id ){

V2I_MSG_msgtype=msgtype; 
// initialize variables
V2I_MSG_vehicle_id=0;
V2I_MSG_arrival_time=0.0; //millisecond
V2I_MSG_turn=0;
V2I_MSG_arrival_velocity=0.0; // micrometer per second /* the velocity at which the vehicle agrees to be traveling when it arrives at the intersection.*/
V2I_MSG_maximum_velocity=0.0; //millimeters per second /* the maximum velocity at which the vehicle can travel.*/
V2I_MSG_maximum_acceleration=0.0; //millimeters per second squared /* the maximum rate at which the vehicle can accelerate.*/
V2I_MSG_minimum_acceleration=0.0; /* the minimum rate at which the vehicle can accelerate (i.e. negative number representing maximum deceleration).*/
V2I_MSG_vehicle_length=0.0; //millimeter /* the length of the vehicle.*/
V2I_MSG_vehicle_width=0.0; //millimeter /* the width of the vehicle.*/
V2I_MSG_reservation_id=0;


if(msgtype ==1){ // REQ
V2I_MSG_vehicle_id=vehicle_id;
V2I_MSG_arrival_time=arrival_Time; //millisecond
V2I_MSG_arrival_lane=arrival_lane;
V2I_MSG_turn=turn;
V2I_MSG_arrival_velocity=arrival_velocity; // micrometer per second /* the velocity at which the vehicle agrees to be traveling when it arrives at the intersection.*/
V2I_MSG_maximum_velocity=maximum_velocity; //millimeters per second /* the maximum velocity at which the vehicle can travel.*/
V2I_MSG_maximum_acceleration=maximum_acceleration; //millimeters per second squared /* the maximum rate at which the vehicle can accelerate.*/
V2I_MSG_minimum_acceleration=minimum_acceleration; //millimeters per second squared /* the minimum rate at which the vehicle can accelerate (i.e. negative number representing maximum deceleration).*/
V2I_MSG_vehicle_length=vehicle_length; //millimeter /* the length of the vehicle.*/
V2I_MSG_vehicle_width=vehicle_width; //millimeter /* the width of the vehicle.*/

}else if(msgtype ==2){ // CHANGE_REQ
V2I_MSG_vehicle_id=vehicle_id;
V2I_MSG_arrival_time=arrival_Time; //millisecond
V2I_MSG_turn=turn;
V2I_MSG_arrival_velocity=arrival_velocity; // micrometer per second /* the velocity at which the vehicle agrees to be traveling when it arrives at the intersection.*/
V2I_MSG_maximum_velocity=maximum_velocity; //millimeters per second /* the maximum velocity at which the vehicle can travel.*/
V2I_MSG_maximum_acceleration=maximum_acceleration; //millimeters per second squared /* the maximum rate at which the vehicle can accelerate.*/
V2I_MSG_minimum_acceleration=minimum_acceleration; /* the minimum rate at which the vehicle can accelerate (i.e. negative number representing maximum deceleration).*/
V2I_MSG_vehicle_length=vehicle_length; //millimeter /* the length of the vehicle.*/
V2I_MSG_vehicle_width=vehicle_width; //millimeter /* the width of the vehicle.*/
V2I_MSG_reservation_id=reservation_id;
}else if(msgtype ==3){ // CANCEL
V2I_MSG_vehicle_id=vehicle_id;
V2I_MSG_reservation_id=reservation_id;
}else if(msgtype ==4){ // DONE
V2I_MSG_vehicle_id=vehicle_id;
V2I_MSG_reservation_id=reservation_id;
}  

//testing

TV2I_MSG_msgtype[vehicle_id]=V2I_MSG_msgtype; /*message type 1:REQ, 2:CHANGE_REQ, 3:CANCEL and 4:DONE */
TV2I_MSG_vehicle_id[vehicle_id]=V2I_MSG_vehicle_id; /* vehicle identifier */ 
TV2I_MSG_arrival_time[vehicle_id]=V2I_MSG_arrival_time; //millisecond /* the time at which the vehicle is planning to arrive at when it reaches the intersection */
TV2I_MSG_arrival_lane[vehicle_id]=V2I_MSG_arrival_lane;  /* the lane the vehicle will arrive at when it reaches the intersection */ // here its the spawn lane , as vehicle doesn't change lanes before arriving at the intersection
TV2I_MSG_turn[vehicle_id]=V2I_MSG_turn; /* vehicle will turn at this direction after reaching the intersection */
TV2I_MSG_arrival_velocity[vehicle_id]=V2I_MSG_arrival_velocity; // micrometer per second /* the velocity at which the vehicle agrees to be traveling when it arrives at the intersection.*/
TV2I_MSG_maximum_velocity[vehicle_id]=V2I_MSG_maximum_velocity; //millimeters per second /* the maximum velocity at which the vehicle can travel.*/
TV2I_MSG_maximum_acceleration[vehicle_id]=V2I_MSG_maximum_acceleration; //millimeters per second squared /* the maximum rate at which the vehicle can accelerate.*/
TV2I_MSG_minimum_acceleration[vehicle_id]=V2I_MSG_minimum_acceleration; /* the minimum rate at which the vehicle can accelerate (i.e. negative number representing maximum deceleration).*/
TV2I_MSG_vehicle_length[vehicle_id]=V2I_MSG_vehicle_length; //millimeter /* the length of the vehicle.*/
TV2I_MSG_vehicle_width[vehicle_id]=V2I_MSG_vehicle_width; //millimeter /* the width of the vehicle.*/
TV2I_MSG_reservation_id[vehicle_id]=V2I_MSG_reservation_id; /* an identifier for the reservation to be changed. */ //used in CHANGE_REQ, CANCEL and DONE

}

void sendV2IMSG(int msgtype, int vehicle_id, double arrival_Time,int arrival_lane ,int turn, double arrival_velocity, double maximum_velocity, double maximum_acceleration, double minimum_acceleration, double vehicle_length, double vehicle_width,int reservation_id ){
createV2IMsg(msgtype, vehicle_id, arrival_Time,arrival_lane,turn, arrival_velocity, maximum_velocity, maximum_acceleration, minimum_acceleration, vehicle_length,vehicle_width,reservation_id);
}

/*for the current time step set the vehicle acceleration according to a sequence of order pairs of acceleration that the vehicle recived in the CONFIRM message */
void set_acceleration_according_to_reservation(double accelerations[2], int id){
//acc[0]: first pair acceleration , acc[1]: first pair interval
// a vehicle can only move with const velocity or const acceleration till it reaches a certain velocity which it continues with until exiting the intersection
//if( (global_time_step * step)  &lt;= (I2V_MSG_arrival_time + accelerations[1]) )
acceleration[id]=accelerations[0];
//else
//acceleration[id]=0;
}

void steering(double steeringangle, double distance,double vehicle_length,double x, double y, double heading,int id, bool run_int_sim){	

			    double beta =  (distance/vehicle_length) * (sin(steeringangle)/cos(steeringangle));

                if (beta &lt; 0.01){
    		        x = x + distance*cos(heading);
			        y = y + distance*sin(heading);
			        heading = (heading + beta) ;
			        if(heading&gt; 2 * PI)
                    heading = heading- 2 * PI;
                    else if(heading &lt; 0.0)
                    heading = 2 * PI + heading;
                    }
			    else{
                    double Radius = distance/beta;
			        x = x - sin(heading)*Radius + sin(heading+beta)* Radius;
			        y = y + cos(heading)*Radius - cos(heading+beta)* Radius;
			        heading = (heading + beta) ;
			        if(heading&gt; 2 * PI)
                    heading = heading- 2 * PI;
                    else if(heading &lt; 0.0)
                    heading = 2 * PI + heading;
                    }
                
                // if this is for test vehicle
                if(run_int_sim==true){
                orientation_internal_sim= heading;    
                positionLM_internal_sim[0]=x;
                positionLM_internal_sim[1]=y;            
                return;
                }
                
                orientation[id]= heading;
                positionLM[id][0]=x;
                positionLM[id][1]=y;
 
}

double getsteeringangle(int ID, bool internal_sim){
bool turning=false;
double sa=0.0;

if(internal_sim==false){
if(orientation[ID] == final_orientation[ID])
return sa;

if(no_of_lanes==3){
if(spawn_lane[ID]==0)
if( positionUM[ID][1] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==2)
if( positionUM[ID][1] -2 &gt;=road_length )
turning=true;
if(spawn_lane[ID]==3)
if( positionUM[ID][0] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==5)
if( positionUM[ID][0] -2 &gt;=road_length )
turning=true;
if(spawn_lane[ID]==6)
if( positionUM[ID][1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][1]&gt;0)
turning=true;
if(spawn_lane[ID]==8)
if( positionUM[ID][1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][1]&gt;0 )
turning=true;
if(spawn_lane[ID]==9)
if( positionUM[ID][0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][0]&gt;0)
turning=true;
if(spawn_lane[ID]==11)
if( positionUM[ID][0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][0]&gt;0)
turning=true;
}else if(no_of_lanes==2){
if(spawn_lane[ID]==0)
if( positionUM[ID][1] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==1)
if( positionUM[ID][1] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==2)
if( positionUM[ID][0] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==3)
if( positionUM[ID][0] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==4)
if( positionUM[ID][1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][1]&gt;0)
turning=true;
if(spawn_lane[ID]==5)
if( positionUM[ID][1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][1]&gt;0)
turning=true;
if(spawn_lane[ID]==6)
if( positionUM[ID][0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][0]&gt;0)
turning=true;
if(spawn_lane[ID]==7)
if( positionUM[ID][0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][0]&gt;0)
turning=true;
// NOW for no_of_lanes=1 , IF VEHICLE IS TURNING then  2m of the front of the vehicle has to be in the intersection before the vehicle can start turning
}else if(no_of_lanes==1){
//N-W
if(spawn_lane[ID]==0 &amp;&amp; dest_lane[ID]==3)
if( positionUM[ID][1] -2 &gt;=road_length)
turning=true;
//N-E
if(spawn_lane[ID]==0  &amp;&amp; dest_lane[ID]==1)
if( positionUM[ID][1] -2 &gt;=road_length)
turning=true;
//E-N
if(spawn_lane[ID]==1 &amp;&amp; dest_lane[ID]==0)
if( positionUM[ID][0] -2 &gt;=road_length)
turning=true;
//E-S
if(spawn_lane[ID]==1 &amp;&amp; dest_lane[ID]==2)
if( positionUM[ID][0] -2 &gt;=road_length)
turning=true;
//S-E
if(spawn_lane[ID]==2 &amp;&amp; dest_lane[ID]==1)
if( positionUM[ID][1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][1]&gt;0)
turning=true;
//S-W
if(spawn_lane[ID]==2 &amp;&amp; dest_lane[ID]==3)
if( positionUM[ID][1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][1]&gt;0)
turning=true;
//W-S
if(spawn_lane[ID]==3 &amp;&amp; dest_lane[ID]==2)
if( positionUM[ID][0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][0]&gt;0)
turning=true;
//W-N
if(spawn_lane[ID]==3 &amp;&amp; dest_lane[ID]==0)
if( positionUM[ID][0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM[ID][0]&gt;0)
turning=true;
}
}else{
if(no_of_lanes==3){
if(spawn_lane[ID]==0)
if( positionUM_internal_sim[1] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==2)
if( positionUM_internal_sim[1] -2 &gt;=road_length )
turning=true;
if(spawn_lane[ID]==3)
if( positionUM_internal_sim[0] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==5)
if( positionUM_internal_sim[0] -2 &gt;=road_length )
turning=true;
if(spawn_lane[ID]==6)
if( positionUM_internal_sim[1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[1]&gt;0)
turning=true;
if(spawn_lane[ID]==8)
if( positionUM_internal_sim[1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[1]&gt;0 )
turning=true;
if(spawn_lane[ID]==9)
if( positionUM_internal_sim[0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[0]&gt;0)
turning=true;
if(spawn_lane[ID]==11)
if( positionUM_internal_sim[0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[0]&gt;0)
turning=true;
}else if(no_of_lanes==2){
if(spawn_lane[ID]==0)
if( positionUM_internal_sim[1] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==1)
if( positionUM_internal_sim[1] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==2)
if( positionUM_internal_sim[0] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==3)
if( positionUM_internal_sim[0] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==4)
if( positionUM_internal_sim[1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[1]&gt;0)
turning=true;
if(spawn_lane[ID]==5)
if( positionUM_internal_sim[1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[1]&gt;0)
turning=true;
if(spawn_lane[ID]==6)
if( positionUM_internal_sim[0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[0]&gt;0)
turning=true;
if(spawn_lane[ID]==7)
if( positionUM_internal_sim[0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[0]&gt;0)
turning=true;
}else if(no_of_lanes==1){
if(spawn_lane[ID]==0 &amp;&amp; dest_lane[ID]==3)
if( positionUM_internal_sim[1] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==0  &amp;&amp; dest_lane[ID]==1)
if( positionUM_internal_sim[1] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==1 &amp;&amp; dest_lane[ID]==0)
if( positionUM_internal_sim[0] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==1 &amp;&amp; dest_lane[ID]==2)
if( positionUM_internal_sim[0] -2 &gt;=road_length)
turning=true;
if(spawn_lane[ID]==2 &amp;&amp; dest_lane[ID]==1)
if( positionUM_internal_sim[1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[1]&gt;0)
turning=true;
if(spawn_lane[ID]==2 &amp;&amp; dest_lane[ID]==3)
if( positionUM_internal_sim[1] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[1]&gt;0)
turning=true;
if(spawn_lane[ID]==3 &amp;&amp; dest_lane[ID]==2)
if( positionUM_internal_sim[0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[0]&gt;0)
turning=true;
if(spawn_lane[ID]==3 &amp;&amp; dest_lane[ID]==0)
if( positionUM_internal_sim[0] +2 &lt;= road_length+intersection_length &amp;&amp; positionUM_internal_sim[0]&gt;0)
turning=true;
}
}


if(turning==true){
// To make this modular we should use tan inverse function, but as it is not included in uppaal library, so the steering angle (sa) here should be altered if the vehicle size and/or intersection length are changed.
if(no_of_lanes==3){
if(spawn_lane[ID]==0 || spawn_lane[ID]==3 || spawn_lane[ID]== 6 || spawn_lane[ID]==9)
//sa=0.27;
sa=0.31;
else if(spawn_lane[ID]==2 || spawn_lane[ID]==5 || spawn_lane[ID]== 8 || spawn_lane[ID]==11)
//sa=-0.7204150817;
sa=-1.0;
} else if(no_of_lanes==2){
if(spawn_lane[ID]==0 || spawn_lane[ID]==2 || spawn_lane[ID]== 4 || spawn_lane[ID]==6)
//sa=0.33;
sa=0.4;
else if(spawn_lane[ID]==1 || spawn_lane[ID]==3 || spawn_lane[ID]== 5 || spawn_lane[ID]==7)
//sa=-0.7204150817;
sa=-1.1;
}else if(no_of_lanes==1){
if((spawn_lane[ID]==0 &amp;&amp; dest_lane[ID]==3) || (spawn_lane[ID]==1 &amp;&amp; dest_lane[ID]==0) || spawn_lane[ID]==2 &amp;&amp; dest_lane[ID]==1 || spawn_lane[ID]==3 &amp;&amp; dest_lane[ID]==2)
sa=0.55;
else if((spawn_lane[ID]==0 &amp;&amp; dest_lane[ID]==1) || (spawn_lane[ID]==1 &amp;&amp; dest_lane[ID]==2) || spawn_lane[ID]==2 &amp;&amp; dest_lane[ID]==3 || spawn_lane[ID]==3 &amp;&amp; dest_lane[ID]==0)
sa=-1.3;
}

} 


return sa;
}

void adjustpositionafterturning(int id){

if(orientation[id] == final_orientation[id])
return;

if(no_of_lanes==3){
if(dest_lane[id]==0 &amp;&amp; orientation[id] &gt; PI/2){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0];
orientation[id]=PI/2;
}
else if(dest_lane[id]==2 &amp;&amp; orientation[id] &lt; PI/2){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0];
orientation[id]=PI/2;
}
else if(dest_lane[id]==3 &amp;&amp; orientation[id] &gt; 0.0 &amp;&amp;  orientation[id] &lt; PI/2){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=0.0;
}
else if(dest_lane[id]==5 &amp;&amp; orientation[id] &lt; 2*PI &amp;&amp; orientation[id] &gt; 3*PI/2 ){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=0.0;
}
else if(dest_lane[id]==6 &amp;&amp; orientation[id] &gt; 3*PI/2){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0]; 
orientation[id]=3*PI/2;
}
else if(dest_lane[id]==8 &amp;&amp; orientation[id] &lt; 3*PI/2 &amp;&amp; orientation[id]&gt; PI){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0];                                     
orientation[id]=3*PI/2;
}
else if(dest_lane[id]==9 &amp;&amp; orientation[id] &gt; PI){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=PI;
}
else if(dest_lane[id]==11 &amp;&amp; orientation[id] &lt; PI){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=PI;
}

}else if(no_of_lanes==2){
if(dest_lane[id]==0 &amp;&amp; orientation[id] &gt; PI/2){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0];
orientation[id]=PI/2;
}
else if(dest_lane[id]==1 &amp;&amp; orientation[id] &lt; PI/2){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0];
orientation[id]=PI/2;
}
else if(dest_lane[id]==2 &amp;&amp; orientation[id] &gt; 0.0 &amp;&amp;  orientation[id] &lt; PI/2){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=0.0;
}
else if(dest_lane[id]==3 &amp;&amp; orientation[id] &lt; 2*PI &amp;&amp; orientation[id] &gt; 3*PI/2 ){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=0.0;
}
else if(dest_lane[id]==4 &amp;&amp; orientation[id] &gt; 3*PI/2){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0]; 
orientation[id]=3*PI/2;
}
else if(dest_lane[id]==5 &amp;&amp; orientation[id] &lt; 3*PI/2 &amp;&amp; orientation[id]&gt; PI){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0]; 
orientation[id]=3*PI/2;
}
else if(dest_lane[id]==6 &amp;&amp; orientation[id] &gt; PI){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=PI;
}
else if(dest_lane[id]==7 &amp;&amp; orientation[id] &lt; PI){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=PI;
}

}else if(no_of_lanes==1){
if((dest_lane[id]==0 &amp;&amp; spawn_lane[id]==1 &amp;&amp; orientation[id] &gt; PI/2) || (dest_lane[id]==0 &amp;&amp; spawn_lane[id]==3 &amp;&amp; orientation[id] &lt; PI/2)){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0];
orientation[id]=PI/2;
}
else if((dest_lane[id]==1 &amp;&amp; spawn_lane[id]==2 &amp;&amp; orientation[id] &gt; 0.0 &amp;&amp;  orientation[id] &lt; PI/2) || (dest_lane[id]==1 &amp;&amp; spawn_lane[id]==0 &amp;&amp; orientation[id] &lt; 2*PI &amp;&amp; orientation[id] &gt; 3*PI/2) ){
positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=0.0;
}
else if((dest_lane[id]==2 &amp;&amp; spawn_lane[id]==3 &amp;&amp; orientation[id] &gt; 3*PI/2) || (dest_lane[id]==2 &amp;&amp; spawn_lane[id]==1 &amp;&amp; orientation[id] &lt; 3*PI/2 &amp;&amp; orientation[id]&gt; PI) ){
positionUL[id][0]=positionLL[id][0];
positionUR[id][0]=positionLR[id][0];
orientation[id]=3*PI/2;
}
else if((dest_lane[id]==3 &amp;&amp; spawn_lane[id]==0 &amp;&amp; orientation[id] &gt; PI) || ( dest_lane[id]==3 &amp;&amp; spawn_lane[id]==2 &amp;&amp; orientation[id] &lt; PI)){

positionUL[id][1]=positionLL[id][1];
positionUR[id][1]=positionLR[id][1];
orientation[id]=PI;
}

}

}

void move(int id){

// update velocity and distance covered by the vehicle in a single time step according to Newtonian kinematics for uniform acceleration
velocity[id]= velocity[id] + acceleration[id] * step; // v=u+at 

//make sure the vehicle is not going backwards or exceeding the speed limit
if(velocity[id] &lt;= 0.0 &amp;&amp; acceleration[id]&lt; 0.0) {acceleration[id]=0.0; velocity[id]=0.0;}
else if(velocity[id] &gt;= speed_limit &amp;&amp; acceleration[id]&gt; 0.0) {acceleration[id]=0.0; velocity[id]=speed_limit;}

distance[id]= velocity[id] * step - 0.5 * acceleration[id] * step * step; // d=vt-0.5at^2 

total_distance_traveled[id]=total_distance_traveled[id] + distance[id];
total_journey_time[id]=total_journey_time[id] + step;
//get steeringangle
steeringangle[id]=getsteeringangle(id,false);

//update vehicle boundary points(UL,UR,LL and LR), calculate some distance parameters and update vehicle's crossing state.

steering(steeringangle[id],distance[id], vehicle_length,positionLM[id][0],positionLM[id][1],orientation[id],id,false);

//TODO: calculate a new steering angle for the final turn step so that vehicle reaches the intended position
// beta=sin_inverse((X-Xold)/Radius + sin(heading))-heading;
// steeringangle_final=tan_inverse(beta * vehicle_length / distance);

//adjust position of vehicle after reaching the intersection exit , so that the vehicle continues in straight line afterwards
adjustpositionafterturning(id);

positionLR[id][0]=positionLM[id][0] +(vehicle_width/2)*sin(orientation[id]);
positionLR[id][1]=positionLM[id][1] -(vehicle_width/2)*cos(orientation[id]);

positionLL[id][0]=positionLM[id][0] -(vehicle_width/2)*sin(orientation[id]);
positionLL[id][1]=positionLM[id][1] +(vehicle_width/2)*cos(orientation[id]);

positionUL[id][0]=positionLL[id][0]+vehicle_length*cos(orientation[id]);
positionUL[id][1]=positionLL[id][1]+vehicle_length*sin(orientation[id]);

positionUR[id][0]=positionLR[id][0]+vehicle_length*cos(orientation[id]);
positionUR[id][1]=positionLR[id][1]+vehicle_length*sin(orientation[id]);

// another position point used in calculating distance between vehicle infront
positionUM[id][0]=positionLM[id][0]+vehicle_length*cos(orientation[id]);
positionUM[id][1]=positionLM[id][1]+vehicle_length*sin(orientation[id]);


if(current_road[id]==0){
distance_to_intersection[id] = road_length - positionUL[id][1]; 

}else if(current_road[id]==1){
distance_to_intersection[id] = road_length - positionUL[id][0]; 

}else if(current_road[id]==2){
distance_to_intersection[id] = positionUL[id][1] - road_length - intersection_length; 

}else if(current_road[id]==3){
distance_to_intersection[id] = positionUL[id][0] - road_length - intersection_length; 

} 

distance_to_vehicle_infront[id]= pow((pow(positionLL[vehicle_infront_id[id]][0] - positionUL[id][0],2) + pow(positionLL[vehicle_infront_id[id]][1] - positionUL[id][1],2)), 0.5) ; 

// calculate the perpendicular distance to the end of journey(perpindicular distance from positionLL point on the vehicle and the positionLL point of the vehicle at the end of its journey , just before vehicle is terminated)
if(dest_road[id]==0)
perpendicular_distance_to_end_of_journeyLL[id]=    2*road_length+intersection_length - positionLL[id][1];   
else if(dest_road[id]==1)
perpendicular_distance_to_end_of_journeyLL[id]=    2*road_length+intersection_length - positionLL[id][0];  
else if(dest_road[id]==2)
perpendicular_distance_to_end_of_journeyLL[id]=    positionLL[id][1] - 0.0;  
else if (dest_road[id]==3)
perpendicular_distance_to_end_of_journeyLL[id]=    positionLL[id][0] - 0.0;  

if(dest_road[id]==0)
perpendicular_distance_to_end_of_journeyLR[id]=    2*road_length+intersection_length - positionLR[id][1];   
else if(dest_road[id]==1)
perpendicular_distance_to_end_of_journeyLR[id]=    2*road_length+intersection_length - positionLR[id][0];  
else if(dest_road[id]==2)
perpendicular_distance_to_end_of_journeyLR[id]=    positionLR[id][1] - 0.0;  
else if (dest_road[id]==3)
perpendicular_distance_to_end_of_journeyLR[id]=    positionLR[id][0] - 0.0;  


// calculate the distance required to get a vehicle to a complete stop 
distance_to_come_to_complete_stop[id]= - 0.5 * vehicle_maxDeceleration * (velocity[id]/vehicle_maxDeceleration) * (velocity[id]/vehicle_maxDeceleration); // d=vt-0.5at^2 , t=(v-u)/a where v=0  

//update vehicle state
if( crossing_state[id]==0 &amp;&amp; distance_to_intersection[id]&lt; 0.0) // if the vehicle's front has crossed the intersection enterance line, then it is in crossing state 1 (crossing)
crossing_state[id]=1; //vehicle has already left its spawn road and is crossing (or has crossed) the intersection

if( crossing_state[id]==1 &amp;&amp; perpendicular_distance_to_end_of_journeyLL[id]&lt; road_length &amp;&amp; perpendicular_distance_to_end_of_journeyLR[id]&lt; road_length ){ // if the vehicle has completely exited the intersection (vehicle's back has crossed the intersection exit line), then it is in crossing state 2 (vehicle has already crossed the intersection)
crossing_state[id]=2;
no_of_vehicles_crossed++; // increment the counter for the number of vehicles which have crossed the intersection
}
//update vehicle's current road and lane and vehicle infront 
if(crossing_state[id]==1 &amp;&amp; once[id]==false){
current_road[id]=dest_road[id];
current_lane[id]=dest_lane[id];
vehicle_infront_id[id]=last_vehicle_on_dest_lane_id[dest_lane[id]]; // make sure name is correct
last_vehicle_on_dest_lane_id[dest_lane[id]]=id; // added it to global variables.
once[id]=true;
}

//vehicles stop for vehicle infront only on the roads and not on the intersection as the AIM policy will handle that
if(crossing_state[id]==0 || crossing_state[id]==2){ 
if(terminatedvehicleID[vehicle_infront_id[id]]==false &amp;&amp; vehicle_infront_id[id]!=0){ 
if(distance_to_vehicle_infront[id] - safety_distance &lt;= distance_to_come_to_complete_stop[id]){
setVehicleAccelerationForStoppingMode(id);
}else setVehicleAccelerationForNormalMode(id);
}else setVehicleAccelerationForNormalMode(id);
}

//If vehicle does not have reservation and it has distance to intersection lower than distance to come to complete stop, it slows down. 
if(crossing_state[id]==0 &amp;&amp; vehicle_has_reservation[id]==false){
 // If the vehicle takes decision to stop it sets the stopping boolean variable to true and will keep in the stopping mode 
 if((distance_to_intersection[id] - dist_to_stop_before_int&lt;= distance_to_come_to_complete_stop[id]))
 setVehicleAccelerationForStoppingMode(id);
}

}



// check if a vehicle is at the beginning of its spawn road
bool vehicleatstartofroad(int id){

double distancetocompletestop=-0.5 * vehicle_maxDeceleration * (speed_limit/vehicle_maxDeceleration)*(speed_limit/vehicle_maxDeceleration);  // d=vt-0.5at^2 , t=(v-u)/a where v=0,u=speed_limit 
double distnotconsforcol = distancetocompletestop + 10.0; // adding safety distance

if(spawn_road[id]==0){
if(positionUL[id][1]&lt;= distnotconsforcol){ 
if(pilledup==false) id_of_first_vehicle_pilling_up=id;
pilledup=true ; return true;
}
}else if(spawn_road[id]==1){
if(positionUL[id][0]&lt;= distnotconsforcol){ 
if(pilledup==false) id_of_first_vehicle_pilling_up=id;
pilledup=true ; return true;
}
}else if(spawn_road[id]==2){
if(positionUL[id][1] &gt;= 2*road_length + intersection_length - distnotconsforcol){ 
if(pilledup==false) id_of_first_vehicle_pilling_up=id;
pilledup=true ; return true;
}
}else if(spawn_road[id]==3){
if(positionUL[id][0] &gt;= 2*road_length + intersection_length - distnotconsforcol){ 
if(pilledup==false) id_of_first_vehicle_pilling_up=id;
pilledup=true ; return true;
}
}

return false;
}


bool checkIfCollisionIsNotRecordedBeforeAndRecordItIfNot(int id1,int id2)
{
int k;
for(k=0; k&lt;no_of_collisions; k++){
if((collidedvehicles.id1[k]==id1 &amp;&amp; collidedvehicles.id2[k]==id2) || (collidedvehicles.id1[k]==id2 &amp;&amp; collidedvehicles.id2[k]==id1))
return false;
}
// Don't count vehicles that were spawned while there is/are vehicle(s) at the start of the road (this means vehicles have pilled up till the spawn point)
if(vehicleatstartofroad(id1))
return false;
if(vehicleatstartofroad(id2))
return false;
 
// otherwise add the vehicles to the struct
collidedvehicles.id1[no_of_collisions]=id1;
collidedvehicles.id2[no_of_collisions]=id2;

return true;
}


// src: W. Randolph Franklin (WRF) PNPOLY - Point Inclusion in Polygon Test : http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
int pnpoly(int nvert, double vertx[4], double verty[4], double testx, double testy){

//nvert 	Number of vertices in the polygon.
//vertx, verty 	Arrays containing the x- and y-coordinates of the polygon's vertices.
//testx, testy	X- and y-coordinate of the test point. 

  int i, j, c = 0;

  for (i = 0, j = nvert-1; i &lt; nvert; j = i++) {

    if ( ((verty[i]&gt;testy) != (verty[j]&gt;testy)) &amp;&amp;

	 (testx &lt; (vertx[j]-vertx[i]) * (testy-verty[i]) / (verty[j]-verty[i]) + vertx[i]) )

       c = !c;
  }

  return c;
}

// we check collisions through testing if any of the first vehicle's edge(corner) points are found to be inside the polygon of the second vehicle, 
// if that was false , we do another test this time by testing if any of the second vehicle's edge(corner) points are found to be inside the polygon of the first vehicle
// We use 'W. Randolph Franklin (WRF) PNPOLY - Point Inclusion in Polygon Test' (http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html)
//  C implementation of Jordan curve theorem to count the number of edges of the polygon that will be crossed by a ray coming out of the test point,
// if the count was an odd number then the point intersects the polygon, otherwise it does not.     
bool checkForCollision(int id1,int id2){

bool collision_exists = false;
double vert1x[4] = {positionUL[id1][0], positionUR[id1][0], positionLL[id1][0],positionLR[id1][0]}; // Array containing the x-coordinates of the first vehicle vertices.
double vert1y[4] = {positionUL[id1][1], positionUR[id1][1], positionLL[id1][1],positionLR[id1][1]}; // Array containing the y-coordinates of the first vehicle vertices.
double vert2x[4] = {positionUL[id2][0], positionUR[id2][0], positionLL[id2][0],positionLR[id2][0]}; // Array containing the x-coordinates of the second vehicle vertices.
double vert2y[4] = {positionUL[id2][1], positionUR[id2][1], positionLL[id2][1],positionLR[id2][1]}; // Array containing the y-coordinates of the second vehicle vertices.

if(pnpoly(4,vert2x,vert2y,positionUL[id1][0],positionUL[id1][1])==1)
collision_exists=true;
else if(pnpoly(4,vert2x,vert2y,positionUR[id1][0],positionUR[id1][1])==1)
collision_exists=true;
else if(pnpoly(4,vert2x,vert2y,positionLL[id1][0],positionLL[id1][1])==1)
collision_exists=true;
else if(pnpoly(4,vert2x,vert2y,positionLR[id1][0],positionLR[id1][1])==1)
collision_exists=true;
else if(pnpoly(4,vert1x,vert1y,positionUL[id2][0],positionUL[id2][1])==1)
collision_exists=true;
else if(pnpoly(4,vert1x,vert1y,positionUR[id2][0],positionUR[id2][1])==1)
collision_exists=true;
else if(pnpoly(4,vert1x,vert1y,positionLL[id2][0],positionLL[id2][1])==1)
collision_exists=true;
else if(pnpoly(4,vert1x,vert1y,positionLR[id2][0],positionLR[id2][1])==1)
collision_exists=true;

if(collision_exists ==false)
return false;
else if(checkIfCollisionIsNotRecordedBeforeAndRecordItIfNot(id1,id2))
return true;
else
return false;
}

void checkCollisions(){
int i;
int j;
for(i=1; i&lt;vehicleID; i++){
for(j=i+1; j&lt;vehicleID; j++){
if(terminatedvehicleID[i]==false &amp;&amp; terminatedvehicleID[j]==false){ // consider vehicles which are not terminated (are still moving)  
if(checkForCollision(i,j)){ 
no_of_collisions++;
if (crossing_state[i]==1 &amp;&amp; crossing_state[j]==1)  
no_of_collisions_on_intersection++; // no of collisions happening within the intersection area
}
}
}
}
}

// check if vehicles have reached the end of their journey , this is used to triger the exit() internal (uppaal) function which terminates the dynamically created vehicles
bool endOfJourney(int id){
if(current_road[id]==0){
// for all lanes on the north road when the y coordinate of the lowerpoint(LL or LR) in the vehicle cross the road end point (2*road_length+intersection_length) the dynamically created vehicle is removed  
if(positionLL[id][1] &gt; 2*road_length+intersection_length)
return true;
} else if(current_road[id]==1){
// for all lanes on the east road when the x coordinate of the lowerpoint(LL or LR) in the vehicle cross the road end point (2*road_length+intersection_length) the dynamically created vehicle is removed  
if(positionLL[id][0] &gt; 2*road_length+intersection_length)
return true;
} else if(current_road[id]==2){
// for all lanes on the south road when the x coordinate of the lowerpoint(LL or LR) in the vehicle cross the road end point (2*road_length+intersection_length) the dynamically created vehicle is removed  
if(positionLL[id][1] &lt; 0.0)
return true;
} else if (current_road[id]==3){
// for all lanes on the west road when the x coordinate of the lowerpoint(LL or LR) in the vehicle cross the road end point (2*road_length+intersection_length) the dynamically created vehicle is removed  
if(positionLL[id][0] &lt; 0.0)
return true;
} 

return false;
}
// terminate the vehicle and calculate the average trip delay
void terminatevehicle(int id){
terminatedvehicleID[id]=true;
positionUL[id][0]=0.0;
positionUL[id][1]=0.0;
positionUR[id][0]=0.0;
positionUR[id][1]=0.0; 
positionLL[id][0]=0.0;
positionLL[id][1]=0.0; 
positionLR[id][0]=0.0; 
positionLR[id][1]=0.0; 
positionLM[id][0]=0.0;
positionLM[id][1]=0.0;

no_of_cleared_vehicles++; // increment the counter for the number of vehicles which have finished their journey

// get the average trip delay : average = old_average * (no-1)/no + new_value /no
average_trip_delay=average_trip_delay* (no_of_cleared_vehicles-1)/no_of_cleared_vehicles + (total_journey_time[id]-(total_distance_traveled[id]/speed_limit))/no_of_cleared_vehicles ;
}

/*calculate the position of the vehicle when it arrives at the enterance of the intersection from knowing the vehicle's arrival lane*/
void getArrivalPositionandOrientationOfVehicle(int arrivallane){

orientation_internal_sim=orientation[V2I_MSG_vehicle_id];// get it from vehicle's current orientation // TODO: maybe I can change this, as the Intersection manager doesn't know the current orientation of the vehicle, evenif it can get it from the arrival lane

if(no_of_lanes==3){
if(arrivallane==0 || arrivallane==1 || arrivallane==2){
positionLM_internal_sim[0]= spawn_pointX[V2I_MSG_vehicle_id];
positionLM_internal_sim[1]= road_length - vehicle_length;
} else if(arrivallane==3 || arrivallane==4 || arrivallane==5){
positionLM_internal_sim[0]= road_length - vehicle_length ;
positionLM_internal_sim[1]= spawn_pointY[V2I_MSG_vehicle_id];
} else if(arrivallane==6 || arrivallane==7 || arrivallane==8){
positionLM_internal_sim[0]= spawn_pointX[V2I_MSG_vehicle_id];
positionLM_internal_sim[1]=road_length + intersection_length +vehicle_length;
} else if(arrivallane==9 || arrivallane==10 || arrivallane==11){
positionLM_internal_sim[0]= road_length + intersection_length +vehicle_length; 
positionLM_internal_sim[1]= spawn_pointY[V2I_MSG_vehicle_id];
}
} else if(no_of_lanes==2){
if(arrivallane==0 || arrivallane==1){
positionLM_internal_sim[0]= spawn_pointX[V2I_MSG_vehicle_id];
positionLM_internal_sim[1]= road_length - vehicle_length;
} else if(arrivallane==2 || arrivallane==3){
positionLM_internal_sim[0]= road_length - vehicle_length ;
positionLM_internal_sim[1]= spawn_pointY[V2I_MSG_vehicle_id];
} else if(arrivallane==4 || arrivallane==5){
positionLM_internal_sim[0]= spawn_pointX[V2I_MSG_vehicle_id];
positionLM_internal_sim[1]= road_length + intersection_length +vehicle_length;
} else if(arrivallane==6 || arrivallane==7){
positionLM_internal_sim[0]= road_length + intersection_length +vehicle_length; 
positionLM_internal_sim[1]= spawn_pointY[V2I_MSG_vehicle_id];
}
} else if(no_of_lanes==1){
if(arrivallane==0){
positionLM_internal_sim[0]= spawn_pointX[V2I_MSG_vehicle_id];
positionLM_internal_sim[1]= road_length - vehicle_length;
} else if(arrivallane==1){
positionLM_internal_sim[0]= road_length - vehicle_length ;
positionLM_internal_sim[1]= spawn_pointY[V2I_MSG_vehicle_id];
} else if(arrivallane==2){
positionLM_internal_sim[0]= spawn_pointX[V2I_MSG_vehicle_id];
positionLM_internal_sim[1]= road_length + intersection_length +vehicle_length;
} else if(arrivallane==3){
positionLM_internal_sim[0]= road_length + intersection_length +vehicle_length;
positionLM_internal_sim[1]= spawn_pointY[V2I_MSG_vehicle_id];
}	
}
}

// we check if a vehicle will occupy a tile through testing if any of the vehicle's edge(corner) points are found to be inside the polygon of the Tile, 
// if that was false , we do another test this time by testing if any of the Tile edge(corner) points are found to be inside the polygon of the vehicle
// We use 'W. Randolph Franklin (WRF) PNPOLY - Point Inclusion in Polygon Test' (http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html)
//  C implementation of Jordan curve theorem to count the number of edges of the polygon that will be crossed by a ray coming out of the test point,
// if the count was an odd number then the point intersects the polygon, otherwise it does not.     
bool checkIfTileIsOccupied(double positionLMx,double positionLMy,double Orientation,double Tile_length,double Tile_width,double Tile_llx,double Tile_lly){

bool Tile_occupied = false;

// reconstruct the vehicle's shape
 positionLRx=positionLMx +(vehicle_width_internal/2) * sin(Orientation);
 positionLRy=positionLMy -(vehicle_width_internal/2) * cos(Orientation);

 positionLLx=positionLMx -(vehicle_width_internal/2) * sin(Orientation);
 positionLLy=positionLMy +(vehicle_width_internal/2) * cos(Orientation);

 positionULx=positionLLx +(vehicle_length_internal) * cos(Orientation);
 positionULy=positionLLy +(vehicle_length_internal) * sin(Orientation);

 positionURx=positionLRx +(vehicle_length_internal) * cos(Orientation);
 positionURy=positionLRy +(vehicle_length_internal) * sin(Orientation);


vert1x[0] = positionULx; vert1x[1]= positionURx; vert1x[2]= positionLLx; vert1x[3]= positionLRx; // Array containing the x-coordinates of the  vehicle vertices.
vert1y[0] = positionULy; vert1y[1]= positionURy; vert1y[2]= positionLLy; vert1y[3]= positionLRy; // Array containing the y-coordinates of the  vehicle vertices.
vert2x[0] = Tile_llx;    vert2x[1]= Tile_llx + Tile_width;  vert2x[2] = Tile_llx; vert2x[3] = Tile_llx + Tile_width; // Array containing the x-coordinates of the tile vertices. UL,UR,LL and LR
vert2y[0] = Tile_lly + Tile_length; vert2y[1]= Tile_lly + Tile_length; vert2y[2]= Tile_lly; vert2y[3]= Tile_lly; // Array containing the y-coordinates of the tile vertices. UL,UR,LL and LR

if(pnpoly(4,vert2x,vert2y,positionULx,positionULy)==1)
Tile_occupied=true;
else if(pnpoly(4,vert2x,vert2y,positionURx,positionURy)==1)
Tile_occupied=true;
else if(pnpoly(4,vert2x,vert2y,positionLLx,positionLLy)==1)
Tile_occupied=true;
else if(pnpoly(4,vert2x,vert2y,positionLRx,positionLRy)==1)
Tile_occupied=true;
else if(pnpoly(4,vert1x,vert1y,Tile_llx,Tile_lly + Tile_length)==1)
Tile_occupied=true;
else if(pnpoly(4,vert1x,vert1y,Tile_llx + Tile_width,Tile_lly + Tile_length)==1)
Tile_occupied=true;
else if(pnpoly(4,vert1x,vert1y, Tile_llx,Tile_lly)==1)
Tile_occupied=true;
else if(pnpoly(4,vert1x,vert1y,Tile_llx + Tile_width,Tile_lly)==1)
Tile_occupied=true;
//point in the middle of the cell
else if(pnpoly(4,vert1x,vert1y,Tile_llx + Tile_width/2, Tile_lly+Tile_length/2)==1)
Tile_occupied=true;

return Tile_occupied;
}

//check if the vehicle has completely exited the intersection 
bool VehicleHasExitedTheIntersection(int destroad,double lmx,double lmy,double orien){

// inorder to do that we check that the 2 back corner points (LL and LR) of the vehicle has crossed the exit road Intersection Line

             positionLR_internal_sim[0]=lmx +(vehicle_width/2)*sin(orien);
             positionLR_internal_sim[1]=lmy -(vehicle_width/2)*cos(orien);

             positionLL_internal_sim[0]=lmx -(vehicle_width/2)*sin(orien);
             positionLL_internal_sim[1]=lmy +(vehicle_width/2)*cos(orien);

            if(destroad==0)
			perpendicular_distance_to_end_of_journey_internal_sim=    2*road_length+intersection_length - positionLR_internal_sim[1];   
			else if(destroad==1)
		    perpendicular_distance_to_end_of_journey_internal_sim=    2*road_length+intersection_length - positionLR_internal_sim[0];  
			else if(destroad==2)
			perpendicular_distance_to_end_of_journey_internal_sim=    positionLR_internal_sim[1] - 0.0;  
			else if (destroad==3)
			perpendicular_distance_to_end_of_journey_internal_sim=    positionLR_internal_sim[0] - 0.0;  

			if(!( perpendicular_distance_to_end_of_journey_internal_sim&lt; road_length)) // if the vehicle has completely exited the intersection (vehicle's back has crossed the intersection exit line), then it is in crossing state 2 (vehicle has already crossed the intersection)
			return false;
    
            if(destroad==0)
			perpendicular_distance_to_end_of_journey_internal_sim=    2*road_length+intersection_length - positionLL_internal_sim[1];   
			else if(destroad==1)
		    perpendicular_distance_to_end_of_journey_internal_sim=    2*road_length+intersection_length - positionLL_internal_sim[0];  
			else if(destroad==2)
			perpendicular_distance_to_end_of_journey_internal_sim=    positionLL_internal_sim[1] - 0.0;  
			else if (destroad==3)
			perpendicular_distance_to_end_of_journey_internal_sim=    positionLL_internal_sim[0] - 0.0;  

            if( perpendicular_distance_to_end_of_journey_internal_sim&lt; road_length) // if the vehicle has completely exited the intersection (vehicle's back has crossed the intersection exit line), then it is in crossing state 2 (vehicle has already crossed the intersection)
			return true;
            else
            return false;


}

/* if message is REQUEST or CHANGE_REQUEST then simulate the vehicle trajectory according to the parameters included in the message. */
/* the acceleration used in the simulation is the 'acceleration' parameter passed to this function*/
/* If at any time during the simulation the vehicle being simulated occupies a reservation tile that is already reserved by another vehicle, the request is rejected by setting the 'reservation_is_accepted' variable to false. Otherwise, the request is accepted by setting the 'reservation_is_accepted' variable to true and the appropriate tiles are reserved for the times they will be required */
void run_internal_simulation(int message,double acceleration){

		// for running the internal simulation it doesn't matter if the message is a REQ or a CHANGE_REQ

			// first create tiles on the intersection area
	       
                 double velocity_internal_sim;
			     double arrival_velocity_internal_sim;
			     double acceleration_internal_sim; // Indicated by the policy, could be a value greater than or equal to zero
			     double distance_internal_sim;
			     double total_journey_time_internal_sim;   
			     double steeringangle_internal_sim;
			     int dest_road_internal_sim; // TODO: better to get it from arrival_lane and turn as Int. manager doesn't directly know the destination lane of the vehicle


                int[0, 1000] i=0;
                int[0, 1000] j=0;
                int[0, 1000] k=0;            
                int[0, 1000] l=0;
                int[-1000, 1000] time=0;
                int[0, 1000] p=0;

			    int [0, 1000] nextOccTile=0;
			    int arrival_stepno_of_reserved_vehicle=0;
			//	int arrival_stepno_of_new_vehicle;
					
					int step_diff = 0;
					int startstepv1 = 0;
					int startstepv2 = 0;
			      	int [0, 400] id_of_reserved_vehicle =0;	
			        int  steps=0;
			        int [0, 1000] nexttile=0;
			        int [0, 1000] nexttilenew=0;		

                    bool alreadyhavereservation=false;

	if(V2I_MSG_vehicle_id == 0) return;		       

                step_no =1; // start from step 1 // a counter to count the number of steps from the time the vehicle is anticipated to enter the intersection
                exitstate=false;
			    acceleration_internal_sim=acceleration;
                velocity_internal_sim=V2I_MSG_arrival_velocity;
                arrival_velocity_internal_sim=V2I_MSG_arrival_velocity;
                total_journey_time_internal_sim=V2I_MSG_arrival_time; 
                dest_road_internal_sim = dest_road[V2I_MSG_vehicle_id];

    orientation_internal_sim=0.0;
    positionLM_internal_sim[0]=0.0;
    positionLM_internal_sim[1]=0.0;
    positionUM_internal_sim[0]=0.0;
    positionUM_internal_sim[1]=0.0;
                        
                        i=0;
                
                    if(onetime==false){
                    double Offsetx;
				    double Offsety;
			        double width;
				    double length;

                 int [0, 1000] X_internal_sim=0;
			     int [0, 1000] Y_internal_sim=0;
			     int [0, 1000] y_internal_sim=0; 
			     int [0, 1000] x_internal_sim=0;
			     int [0, 1000] tileid = 1; // start from tile 1


                NoOfTiles=castDoubleToInt(ceil(intersection_length / granularity) * ceil(intersection_length / granularity));


			X_internal_sim = castDoubleToInt(ceil((area_width) / distx));

			Y_internal_sim = castDoubleToInt(ceil((area_length) / disty));

		      for(y_internal_sim = 0; y_internal_sim &lt; Y_internal_sim; y_internal_sim++) {
						    	  for(x_internal_sim = 0; x_internal_sim &lt; X_internal_sim; x_internal_sim++) {
						    
						        // Offset of tile
						        Offsetx = x_internal_sim * distx;
				                Offsety  = y_internal_sim * disty;
						        

                                 if(distx &lt; area_width - Offsetx)
						        width = distx;
						        else

                                width = area_width - Offsetx;
						        

                                if(disty &lt; area_length - Offsety)
							        length = disty;
							        else

                            	length = area_length - Offsety;					

						        Tile_length[tileid]= length; 
						        Tile_width[tileid] =width ; 
						        Tile_llx[tileid]=initx +Offsetx; 
						    	Tile_lly[tileid]=inity +Offsety;      
        
                                //identfiy edge tile(tiles that are not surrounded by other tiles on all sides) from internal tiles
                                if(Tile_llx[tileid]==road_length || Tile_llx[tileid]==road_length + intersection_length - Tile_width[tileid] || Tile_lly[tileid]==road_length || Tile_lly[tileid]==road_length+intersection_length-Tile_length[tileid] )
                               isEdgeTile[tileid]=true;                                
                               else
                                isEdgeTile[tileid]=false;


                                //increment tileid
						        tileid++;
						        
						      }
						    }
                        onetime=true;	   
						   }
					// TODO	: See which of those tiles are Edge Tiles;

			getArrivalPositionandOrientationOfVehicle(V2I_MSG_arrival_lane);  
            exitstate=false;

           positionUM_internal_sim[0]=positionLM_internal_sim[0]+vehicle_length_internal*cos(orientation_internal_sim);
           positionUM_internal_sim[1]=positionLM_internal_sim[1]+vehicle_length_internal*sin(orientation_internal_sim);

            //initialize tempOccTiles list to zero
            for(i=1;i&lt;max_noOfsteps;i++){
            for(j=1;j&lt;max_nooftiles_occupied;j++){
			tempOccTiles[i][j]=0.0; // time is recorded implicitly by the number of steps (to get the real time, we will have to add the time from these steps over the arrival_time of the vehicle)
			}
            }

			while(exitstate==false &amp;&amp; step_no &lt; max_noOfsteps){
			// move test vehicle
			// make sure the vehicle will not go in reverse(backward) direction
			if(velocity_internal_sim &lt;= 0.0 &amp;&amp; acceleration_internal_sim&lt; 0.0) {acceleration_internal_sim=0.0; velocity_internal_sim=0.0;}
			else if(velocity_internal_sim &gt;= speed_limit &amp;&amp; acceleration_internal_sim&gt; 0.0) {acceleration_internal_sim=0.0; velocity_internal_sim=speed_limit;}

			// update velocity and distance covered by the vehicle in a single time step according to Newtonian kinematics for uniform acceleration
			velocity_internal_sim= velocity_internal_sim + acceleration_internal_sim * step; // v=u+at 
			distance_internal_sim= velocity_internal_sim * step - 0.5 * acceleration_internal_sim * step * step; // d=vt-0.5at^2 

			//get steeringangle
			 steeringangle_internal_sim=getsteeringangle(V2I_MSG_vehicle_id,true);

			//update vehicle boundary points(UL,UR,LL and LR), calculate some distance parameters and update vehicle's crossing state.

			steering(steeringangle_internal_sim,distance_internal_sim,vehicle_length_internal, positionLM_internal_sim[0], positionLM_internal_sim[1],orientation_internal_sim,V2I_MSG_vehicle_id,true);

             positionUM_internal_sim[0]=positionLM_internal_sim[0]+vehicle_length_internal * cos(orientation_internal_sim);
             positionUM_internal_sim[1]=positionLM_internal_sim[1]+vehicle_length_internal * sin(orientation_internal_sim);
			

            //check if test vehicle has exited the intersection or not
            if(VehicleHasExitedTheIntersection(dest_road_internal_sim,positionLM_internal_sim[0],positionLM_internal_sim[1],orientation_internal_sim))
            exitstate=true;
    
			//increase time step
			total_journey_time_internal_sim=total_journey_time_internal_sim + step;

			//find occupied tiles
			nextOccTile=1;

            //record tiles that will be occupied by this vehicle at each time step in vehicles intersection traversal
			for(j=1;j&lt;NoOfTiles+1;j++){
			if(checkIfTileIsOccupied(positionLM_internal_sim[0],positionLM_internal_sim[1],orientation_internal_sim,Tile_length[j], Tile_width[j],Tile_llx[j],Tile_lly[j]))
			{ 
			// record time and list_id in tempOccTiles
	 // time is recorded implicitly by the number of steps (to get the real time, we will have to add the time from these steps over the arrival_time of the vehicle)
			tempOccTiles[step_no][nextOccTile]=j;
            nextOccTile++;
			}
			}


			// increment time step
			step_no++;
			} // end of while loop
			
        // make sure these tiles are not reserved by another vehicle 
			
			arrival_stepno_of_new_vehicle[V2I_MSG_vehicle_id]=castDoubleToInt(V2I_MSG_arrival_time / 0.02);
            //arrival_stepno_of_new_vehicle[V2I_MSG_vehicle_id]=castDoubleToInt(ceil(V2I_MSG_arrival_time / 0.02));
           

			for(i=0;i&lt;reserved_vehicle_id_list_size;i++){
					
					id_of_reserved_vehicle=reserved_vehicle_id_list[i];	

                    arrival_stepno_of_reserved_vehicle=castDoubleToInt(arrival_time_list[reserved_vehicle_id_list[i]] / 0.02);
                    //arrival_stepno_of_reserved_vehicle=castDoubleToInt(ceil(arrival_time_list[reserved_vehicle_id_list[i]] / 0.02));
                    					
					if(arrival_stepno_of_reserved_vehicle &lt;= arrival_stepno_of_new_vehicle[V2I_MSG_vehicle_id]){
						step_diff=arrival_stepno_of_new_vehicle[V2I_MSG_vehicle_id] - arrival_stepno_of_reserved_vehicle;
						startstepv1=step_diff;
						startstepv2=0;	
                     
					}else if(arrival_stepno_of_reserved_vehicle &gt; arrival_stepno_of_new_vehicle[V2I_MSG_vehicle_id]){
						step_diff=arrival_stepno_of_reserved_vehicle - arrival_stepno_of_new_vehicle[V2I_MSG_vehicle_id];
				//		startstepv1=0;
				//		startstepv2=step_diff;
                  startstepv1=-step_diff;
                  startstepv2=0;    	
					}
					
                   if(id_of_reserved_vehicle &gt; 0){ 
					for(steps=1;steps&lt;max_noOfsteps-step_diff;steps++){ 
					for(nexttile=1;nexttile&lt;max_nooftiles_occupied;nexttile++){
					for(nexttilenew=1;nexttilenew&lt;max_nooftiles_occupied;nexttilenew++){	

        if(dest_lane[V2I_MSG_vehicle_id]==dest_lane[id_of_reserved_vehicle] &amp;&amp; isEdgeTile[castDoubleToInt(tempOccTiles[startstepv2+steps][nexttilenew])]==true){
  
               if(tempOccTiles[startstepv2+steps][nexttilenew] &gt; 0){                             
                     for(time=startstepv1+steps-edgetimeBuffer;time&lt;startstepv1+steps+edgetimeBuffer;time++){
                           if(time &gt; 0){      
                               if(tempOccTiles[startstepv2+steps][nexttilenew] == OccTiles[id_of_reserved_vehicle][time][nexttile]){
                                        reservation_is_accepted=false;                    
                                        return;
                    }   
                    }    
                   }
                   }
          }else{ //internal tile
                    if(tempOccTiles[startstepv2+steps][nexttilenew] &gt; 0){                             
             for(time=startstepv1+steps-internaltimeBuffer;time&lt;startstepv1+steps+internaltimeBuffer;time++){
               if(time &gt; 0){      
               if(tempOccTiles[startstepv2+steps][nexttilenew] == OccTiles[id_of_reserved_vehicle][time][nexttile]){
                                        reservation_is_accepted=false;                    
                                        return;
                    }   
                    }    
                   }
                   }
                    }
		
					}	
					}
			     	}
                    }
					}


			// if we reach here that means the reservation was accepted
			//Add reservation to reservation list and increment reservation list size 
			//Don't reserve if the reservation list already includes vehicle_id (i.e. in case a change reservation we overwrite the reservation id with the new one, so we use the same reservation id as the old one, this is possible as we don't assume messages are lost in this model)
            for(p=0; p&lt;reserved_vehicle_id_list_size;p++){
            if(reserved_vehicle_id_list[p]==V2I_MSG_vehicle_id)
            alreadyhavereservation=true;        
            }
            
            if( alreadyhavereservation==false ){     
            reserved_vehicle_id_list[reserved_vehicle_id_list_size]=V2I_MSG_vehicle_id;
			reserved_vehicle_id_list_size++;
            }

            //And fill the Occupied tiles list
        for(k=1;k&lt;max_noOfsteps;k++){
		    for(l=1;l&lt;max_nooftiles_occupied;l++)
			    OccTiles[V2I_MSG_vehicle_id][k][l]= tempOccTiles[k][l];
			}
			
            // update some fields which will be sent in the Confirm message
			I2V_reservation_id=V2I_MSG_vehicle_id; // reservation_id is same as vehicle_id
			I2V_arrival_time=V2I_MSG_arrival_time;
			I2V_early_error=0.0; // we don't use this field
			I2V_late_error=0.0;  // we don't use this field
			I2V_arrival_lane=V2I_MSG_arrival_lane;
			I2V_arrival_velocity=V2I_MSG_arrival_velocity;; //same as the velocity included in the request. //TODO: make sure you don't need to change that at a later stage

			//acceleration profile
			if(acceleration&gt;0.0){
			I2V_accelerations[0]=acceleration;//acceleration used in intersection until reaching speed limit or until exiting
			I2V_accelerations[1]=(velocity_internal_sim - arrival_velocity_internal_sim)/acceleration; //Duration of acceleration //v=u+at
			}else{ I2V_accelerations[0]=0.0;I2V_accelerations[1]=0.0;}

			//else do nothing as accleration profile would be zero (having constant velocity throughout the intersection traversal)

			I2V_stop_required=false; 

			// then update arrival_time_list with the new value
			arrival_time_list[V2I_MSG_vehicle_id]=V2I_MSG_arrival_time;

			reservation_is_accepted=true;
			}

		
/* used to check if the request is accpeted or not based on running an internal simulation of the vehicle's trajectory*/
void check_request(int message,int allowed_acceleration){
	if(allowed_acceleration==1){
	   run_internal_simulation(message,V2I_MSG_maximum_acceleration); /*run the internal simulation with the test vehicle having maximum acceleration*/
			if(reservation_is_accepted==false){ /* if rejected try with constant velocity only if the arrival velocity will be higher than 10 m/s */
			if(V2I_MSG_arrival_velocity&gt; 10) 
			run_internal_simulation(message,0.0); /*run the internal simulation with the test vehicle having no acceleration*/
			}
			}else if (allowed_acceleration==0) run_internal_simulation(message,0.0); /*run the internal simulation with the test vehicle having no acceleration*/

			}	

/* used by the Intersection-Controller to remove reservation of reserved tiles by a specific vehicle*/
void cancel_reservation(int reservation_id){
// We will assume that reservation_id is equal to vehicle_id; 
//remove occupied tiles of vehicle from occTiles
int k,l,m;
for(k=1;k&lt;max_noOfsteps;k++){
for(l=1;l&lt;max_nooftiles_occupied;l++)
OccTiles[reservation_id][k][l]=0;
}
//remove reservation from reservation list and decrement the list size
for(m=0;m&lt;reserved_vehicle_id_list_size;m++){
if(reserved_vehicle_id_list[m]==reservation_id){
reserved_vehicle_id_list[m]=0;
return;
}
}

}

void createI2V(int I2V_Messagetype,int I2V_Reservation_id,double I2V_Arrival_time,double I2V_Early_error, double I2V_Late_error, int I2V_Arrival_lane, double I2V_Arrival_velocity, double I2V_Accelerations[2], bool I2V_Stop_required){

I2V_MSG_msgtype=I2V_Messagetype; 

if(I2V_Messagetype==1){ // CONFIRM
I2V_MSG_reservation_id=I2V_Reservation_id;
I2V_MSG_arrival_time=I2V_Arrival_time; //millisecond
I2V_MSG_early_error= I2V_Early_error;
I2V_MSG_late_error= I2V_Late_error;
I2V_MSG_arrival_lane=I2V_Arrival_lane;
I2V_MSG_arrival_velocity=I2V_Arrival_velocity; // micrometer per second /* the velocity at which the Intersection manager would like the vehicle to be traveling at when it arrives at the intersection.*/
I2V_MSG_accelerations[0]=I2V_Accelerations[0]; //millimeters per second squared
I2V_MSG_accelerations[1]=I2V_Accelerations[1]; //millimeters per second squared
}else if(I2V_Messagetype==2){ // REJECT
I2V_MSG_stop_required=I2V_Stop_required;
}else if(I2V_Messagetype==3){ // ACKNOWLEDGE
I2V_MSG_reservation_id=I2V_Reservation_id;
}

//For simulation purposes, to look at the content of the messages

TI2V_MSG_msgtype[V2I_MSG_vehicle_id]=I2V_MSG_msgtype; // 1:CONFIRM,2:REJECT,3:ACK
TI2V_MSG_reservation_id[V2I_MSG_vehicle_id]=I2V_MSG_reservation_id;  /* a unique identifier for the reservation just created. */ // used in CONFIRM and ACK
TI2V_MSG_arrival_time[V2I_MSG_vehicle_id]=I2V_MSG_arrival_time; /* the absolute time at which the vehicle is expected to arrive. */
TI2V_MSG_early_error[V2I_MSG_vehicle_id]=I2V_MSG_early_error; /* the tolerable error (early) in arrival time for the vehicle. */
TI2V_MSG_late_error[V2I_MSG_vehicle_id]=I2V_MSG_late_error; /* the tolerable error (late) in arrival time for the vehicle. */
TI2V_MSG_arrival_lane[V2I_MSG_vehicle_id]=I2V_MSG_arrival_lane; /* a unique identifier for the lane in which the vehicle should be when it arrives at the intersection. */
TI2V_MSG_arrival_velocity[V2I_MSG_vehicle_id]=I2V_MSG_arrival_velocity; /* the velocity at which the vehicle is expected to be traveling when it arrives at the intersection. */
TI2V_MSG_accelerations[0][V2I_MSG_vehicle_id]=I2V_MSG_accelerations[0]; /* acceleration and duration of acceleration, after this duration if the vehicle is still in the intersection it should move with a const speed*/
TI2V_MSG_accelerations[1][V2I_MSG_vehicle_id]=I2V_MSG_accelerations[1];
TI2V_MSG_stop_required[V2I_MSG_vehicle_id]=I2V_MSG_stop_required; /* a boolean value indicating whether the vehicle must first come to a full stop before entering the intersection. */ //used in REJECT only


}

void sendI2V(int I2V_Messagetype,int I2V_Reservation_id,double I2V_Arrival_time,double I2V_Early_error, double I2V_Late_error, int I2V_Arrival_lane, double I2V_Arrival_velocity, double I2V_Accelerations[2], bool I2V_Stop_required){
createI2V(I2V_Messagetype,I2V_Reservation_id,I2V_Arrival_time,I2V_Early_error,I2V_Late_error,I2V_Arrival_lane,I2V_Arrival_velocity,I2V_Accelerations,I2V_Stop_required);
}

/* process messages according to the policy chosen*/
void processV2IMsg(int messagetype){

	if(messagetype==1)//REQ
		check_request(1,1); /* allowed accleration in this policy */
	else if(messagetype==2){//CHANGE_REQ
		check_request(2,1); /* allowed accleration in this policy */	 
     }else if(messagetype==3){ //CANCEL 
		cancel_reservation(V2I_MSG_reservation_id);
        I2V_reservation_id=	V2I_MSG_reservation_id;
       }else if(messagetype==4){ // DONE
	cancel_reservation(V2I_MSG_reservation_id);		
    I2V_reservation_id=	V2I_MSG_reservation_id;	
    }

}

void AIMpolicy_IM(){

//initialize message variables to zero
I2V_MSG_msgtype=0; 
I2V_MSG_reservation_id=0;  
I2V_MSG_arrival_time=0.0; 
I2V_MSG_early_error=0.0; 
I2V_MSG_late_error=0.0; 
I2V_MSG_arrival_lane=0; 
I2V_MSG_arrival_velocity=0.0; 
I2V_MSG_accelerations[0]=0.0;
I2V_MSG_accelerations[1]=0.0; 
I2V_MSG_stop_required=0;

if(channel_id &gt; 0){

// V2I message has to contain at least a vehicle id
if(V2I_MSG_vehicle_id==0 || V2I_MSG_msgtype==0)
return;

reservation_is_accepted=false;

if(V2I_MSG_msgtype==1){ //REQ 
	processV2IMsg(1);	
	if(reservation_is_accepted==true){ /* reservation request was accepted */ 
sendI2V(1,I2V_reservation_id,I2V_arrival_time,I2V_early_error, I2V_late_error, I2V_arrival_lane, I2V_arrival_velocity, I2V_accelerations,I2V_stop_required);//CONFIRM /* includes reservation parameters and the vehicle_id of the vehicle that is sent to */ 
	}else sendI2V(2,0,0.0,0.0,0.0,0,0.0,I2V_accelerations,I2V_stop_required);//REJECT; /* includes the vehicle_id of the vehicle that is sent to */ 

} else if(V2I_MSG_msgtype==2){ //CHANGE_REQ	
	processV2IMsg(2);	
	if(reservation_is_accepted==true) /* reservation request was accepted */ 
		sendI2V(1,I2V_reservation_id,I2V_arrival_time,I2V_early_error, I2V_late_error, I2V_arrival_lane, I2V_arrival_velocity, I2V_accelerations,I2V_stop_required);//CONFIRM /* includes reservation parameters and the vehicle_id of the vehicle that is sent to */ 
	else sendI2V(2,0,0.0,0.0,0.0,0,0.0,I2V_accelerations,I2V_stop_required);//REJECT; /* includes the vehicle_id of the vehicle that is sent to */ 

}else if(V2I_MSG_msgtype==3){ //CANCEL
	processV2IMsg(3);
	sendI2V(3,I2V_reservation_id,0.0,0.0,0.0,0,0.0,I2V_accelerations,false);//ACKNOWLEDGE;
}else if(V2I_MSG_msgtype==4){ //DONE
	processV2IMsg(4);
    sendI2V(3,I2V_reservation_id,0.0,0.0,0.0,0,0.0,I2V_accelerations,false);//ACKNOWLEDGE;
}

}
}

bool NothingToSend(int id){
if(crossing_state[id]==1)
return true;
else
return false;
}


void driverAgent_sending(int id){

//1:REQ,2:CHANGE_REQ,3:CANCEL,4:DONE

// We did not implement Timeouts
// Eventhough we have implemented Optimistic/Pessimistic arrival estimation, we have used only Optimistic arrival estimation in verification

double threshold_over_schedueled_time=0.02; 
double arrival_velocity,arrival_Time; 
double error=0.06; //seconds, allow for small errors in estimating time as mentioned in AIM paper.

//initialize message fields to zeros
V2I_MSG_msgtype=0; 
V2I_MSG_vehicle_id=0;
V2I_MSG_arrival_time=0.0;
V2I_MSG_arrival_lane=0; 
V2I_MSG_turn=0;
V2I_MSG_arrival_velocity=0.0;  
V2I_MSG_maximum_velocity=0.0; 
V2I_MSG_maximum_acceleration=0.0;
V2I_MSG_minimum_acceleration=0.0;
V2I_MSG_vehicle_length=0; 
V2I_MSG_vehicle_width=0; 
V2I_MSG_reservation_id=0;

if(crossing_state[id]==0){ //INTERSECTION_APPROACH 


if(Mood[id]==0)
      arrival_velocity=estimate_arrival_time_and_velocity_to_intersection(0, id);
else
      arrival_velocity=estimate_arrival_time_and_velocity_to_intersection(1, id);	 	   

arrival_Time=arrival_time[id];

	if(vehicle_has_reservation[id]==true){ /* if the vehicle has a reservation already*/
	  if(arrival_Time  &gt; scheduled_arrival_time_in_reservation[id] + error){
         if((distance_to_intersection[id] - dist_to_stop_before_int &gt;= distance_to_come_to_complete_stop[id])){ // vehicle sends cancel messages only if it can stop before the intersection(with threshold) otherwise it doesn't cancel, thats the main reason AIM has buffers
	     sendV2IMSG(3, id,arrival_Time,0,0,0.0,0.0,0.0,0.0,0.0,0.0,vehicle_reservation_id[id]);//send CANCEL message; /* if the vehicle cannot make it on time, it cancels its reservation*/
        vehicle_has_reservation[id]=false;			
        }		
     }else sendV2IMSG(0, 0,0.0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0); // no message to send
        
        }else { // send reservation requests only if vehicle infront has obtained a reservation, or if there was no vehicle infront (implicit reservation distance without having reservation distance)
if(vehicle_has_reservation[vehicle_infront_id[id]]==true || vehicle_infront_id[id] &lt; 1 || terminatedvehicleID[id]==true)
sendV2IMSG(1, id,arrival_Time,spawn_lane[id],turn_dir[id],arrival_velocity,speed_limit,vehicle_maxAcceleration,vehicle_maxDeceleration,vehicle_length,vehicle_width,0); //REQ;/*if vehicle had no reservation then send a reservation request with the arrival time that was set earlier*/	
else sendV2IMSG(0, 0,0.0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0); // no message to send       
}
 
}else if(crossing_state[id]==2) sendV2IMSG(4,id,arrival_Time,0,0,0.0,0.0,0.0,0.0,0.0,0.0,vehicle_reservation_id[id]); /* send DONE messages when vehicle exits the intersection. For how long to continue sending DONE messages is not explicitly mentioned by the authours of AIM protocol*/

}

void driverAgent_receiving(int id){

double Deceleration_value=vehicle_maxDeceleration; // This value is not explicitly given in AIM
//testing=21;
if (crossing_state[id]==1){
set_acceleration_according_to_reservation(accprofile[id], id); /* Set acceleration according to parameters of reservation */
}else if(crossing_state[id]==0 &amp;&amp; I2V_MSG_msgtype ==2){ //* if reservation request is rejected start decelerating with a certain deceleration value unless the rejection came in response of a change-reservation request , in case it came due to change-reservation then do nothing(i.e. keep the old reservation) */
 //acceleration[id]= Deceleration_value; 
    if(V2I_MSG_msgtype ==1)
    vehicle_has_reservation[id]=false; //set the vehicle_has_reservation[id] boolean parameter to false.
}
// if we are in intersection approach state and we got a confirmation then no need to act until we reach the intersection as we are already going at the right speed 
//just set the vehicle_has_reservation[id] boolean parameter to true.
else if(crossing_state[id]==0 &amp;&amp; I2V_MSG_msgtype ==1){
vehicle_has_reservation[id]=true;
// fill these with the right value from received message:
scheduled_arrival_time_in_reservation[id]=I2V_MSG_arrival_time;
vehicle_reservation_id[id]=I2V_MSG_reservation_id;
accprofile[id][0]=I2V_MSG_accelerations[0];
accprofile[id][1]=I2V_MSG_accelerations[1];
}//else if(crossing_state[id]==0 &amp;&amp; I2V_MSG_msgtype ==3){}
}

bool IntersectionApproach(int id){ if((distance_to_intersection[id]&lt;Denter) &amp;&amp; (distance_to_intersection[id]&gt; 0)) return true; else return false;}</declaration>
	<template>
		<name>Traffic</name>
		<declaration>clock x;</declaration>
		<location id="id0" x="111" y="17">
			<label kind="invariant" x="76" y="25">x&lt;=spawn_time</label>
		</location>
		<init ref="id0"/>
		<transition>
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="guard" x="76" y="-85">x==spawn_time</label>
			<label kind="assignment" x="17" y="-68">spawn Vehicle(++ vehicleID),x=0</label>
			<nail x="34" y="-42"/>
			<nail x="212" y="-42"/>
		</transition>
	</template>
	<template>
		<name>CheckCollisions</name>
		<declaration>clock x;</declaration>
		<location id="id1" x="-442" y="-144">
			<label kind="invariant" x="-452" y="-127">x&lt;=1</label>
		</location>
		<init ref="id1"/>
		<transition>
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="guard" x="-450" y="-289">x==1</label>
			<label kind="assignment" x="-484" y="-263">checkCollisions(), 
x=0</label>
			<nail x="-561" y="-272"/>
			<nail x="-229" y="-263"/>
		</transition>
	</template>
	<template>
		<name>Vehicle</name>
		<parameter>const int id</parameter>
		<declaration>clock x;</declaration>
		<location id="id2" x="-110" y="297">
		</location>
		<location id="id3" x="-136" y="348">
			<committed/>
		</location>
		<location id="id4" x="-68" y="255">
			<committed/>
		</location>
		<location id="id5" x="-187" y="161">
			<name x="-297" y="144">wait_to_send</name>
			<committed/>
		</location>
		<location id="id6" x="-178" y="467">
			<label kind="invariant" x="-161" y="450">x&lt;=1</label>
		</location>
		<location id="id7" x="-93" y="25">
			<name x="-68" y="17">Initialize</name>
			<committed/>
		</location>
		<location id="id8" x="-127" y="561">
			<name x="-102" y="552">Terminate</name>
		</location>
		<location id="id9" x="-85" y="93">
			<name x="-51" y="84">Move</name>
			<label kind="invariant" x="8" y="85">x&lt;=1</label>
		</location>
		<location id="id10" x="-127" y="-94">
			<name x="-137" y="-128">Right</name>
			<committed/>
		</location>
		<location id="id11" x="-212" y="-94">
			<name x="-222" y="-128">Left</name>
			<committed/>
		</location>
		<location id="id12" x="-42" y="-221">
			<name x="-52" y="-255">Straight</name>
			<committed/>
		</location>
		<location id="id13" x="-144" y="-221">
			<name x="-154" y="-255">Turn</name>
			<committed/>
		</location>
		<location id="id14" x="0" y="-450">
			<name x="17" y="-459">West</name>
			<committed/>
		</location>
		<location id="id15" x="-59" y="-459">
			<name x="-85" y="-451">South</name>
			<committed/>
		</location>
		<location id="id16" x="-127" y="-442">
			<name x="-170" y="-450">East</name>
			<committed/>
		</location>
		<location id="id17" x="-195" y="-442">
			<name x="-255" y="-451">North</name>
			<committed/>
		</location>
		<location id="id18" x="-85" y="-620">
			<committed/>
		</location>
		<branchpoint id="id19" x="-76" y="-569">
		</branchpoint>
		<branchpoint id="id20" x="-153" y="-161">
		</branchpoint>
		<branchpoint id="id21" x="-85" y="-280">
		</branchpoint>
		<init ref="id18"/>
		<transition>
			<source ref="id19"/>
			<target ref="id14"/>
			<label kind="probability" x="-34" y="-527">1</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id15"/>
			<label kind="probability" x="-67" y="-514">1</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id16"/>
			<label kind="probability" x="-101" y="-505">1</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id17"/>
			<label kind="probability" x="-177" y="-505">1</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id19"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-119" y="323">I2V?</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id6"/>
			<label kind="assignment" x="-144" y="374">driverAgent_receiving(id),
channel_id=0,
channel_busy=false,
x=0</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id9"/>
			<label kind="guard" x="-561" y="0">x==1&amp;&amp;!(IntersectionApproach(id))</label>
			<label kind="assignment" x="-518" y="34">move(id),
x=0</label>
			<nail x="-426" y="110"/>
			<nail x="-417" y="-34"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-85" y="289">V2I!</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id4"/>
			<label kind="guard" x="-153" y="161">channel_busy==false</label>
			<label kind="assignment" x="-144" y="178">channel_busy=true,
channel_id=id,
driverAgent_sending(id)</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id5"/>
			<label kind="guard" x="-442" y="314">x==1 &amp;&amp; !(endOfJourney(id))</label>
			<label kind="assignment" x="-433" y="331">move(id),x=0</label>
			<nail x="-366" y="391"/>
			<nail x="-374" y="187"/>
			<nail x="-331" y="187"/>
			<nail x="-297" y="187"/>
			<nail x="-246" y="178"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id5"/>
			<label kind="guard" x="-110" y="119">x==1 &amp;&amp; IntersectionApproach(id)</label>
			<label kind="assignment" x="-127" y="136">x=0</label>
			<nail x="-161" y="153"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id9"/>
			<label kind="assignment" x="-144" y="51">setVehInitialState(id)</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="guard" x="-144" y="476">endOfJourney(id)</label>
			<label kind="assignment" x="-136" y="501">terminatevehicle(id),exit()</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id7"/>
			<label kind="assignment" x="-102" y="-153">chooseSpawnLane(id,2)</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id7"/>
			<label kind="assignment" x="-161" y="-43">chooseSpawnLane(id,3)</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id7"/>
			<label kind="assignment" x="-314" y="-68">chooseSpawnLane(id,1)</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id10"/>
			<label kind="probability" x="-153" y="-128">1</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id11"/>
			<label kind="probability" x="-182" y="-128">1</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id20"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id12"/>
			<label kind="probability" x="-76" y="-255">1</label>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id13"/>
			<label kind="probability" x="-114" y="-250">2</label>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id21"/>
			<label kind="assignment" x="-76" y="-331">spawn_road[id]=3</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id21"/>
			<label kind="assignment" x="-127" y="-357">spawn_road[id]=2</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id21"/>
			<label kind="assignment" x="-178" y="-382">spawn_road[id]=1</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id21"/>
			<label kind="assignment" x="-263" y="-408">spawn_road[id]=0</label>
		</transition>
	</template>
	<template>
		<name>IntersectionManager</name>
		<location id="id22" x="-739" y="-909">
			<committed/>
		</location>
		<location id="id23" x="-552" y="-901">
			<name x="-535" y="-918">Process</name>
			<committed/>
		</location>
		<location id="id24" x="-552" y="-1003">
			<name x="-527" y="-1011">Listening</name>
		</location>
		<location id="id25" x="-552" y="-1105">
			<committed/>
		</location>
		<init ref="id25"/>
		<transition>
			<source ref="id23"/>
			<target ref="id22"/>
			<label kind="assignment" x="-680" y="-892">AIMpolicy_IM()</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="-654" y="-986">I2V!</label>
			<nail x="-663" y="-952"/>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id23"/>
			<label kind="synchronisation" x="-531" y="-977">V2I?</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id24"/>
		</transition>
	</template>
	<system>system IntersectionManager,Traffic, CheckCollisions;
    </system>
	<queries>
		<query>
			<formula>Pr([][0,1000] no_of_collisions == 0)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>simulate 1 [&lt;=1000] {no_of_lanes,positionLM[1][0],positionLM[1][1],orientation[1],positionLM[2][0],positionLM[2][1],orientation[2],positionLM[3][0],positionLM[3][1],orientation[3],positionLM[4][0],positionLM[4][1],orientation[4],positionLM[5][0],positionLM[5][1],orientation[5],positionLM[6][0],positionLM[6][1],orientation[6],positionLM[7][0],positionLM[7][1],orientation[7],positionLM[8][0],positionLM[8][1],orientation[8],positionLM[9][0],positionLM[9][1],orientation[9],positionLM[10][0],positionLM[10][1],orientation[10],positionLM[11][0],positionLM[11][1],orientation[11],positionLM[12][0],positionLM[12][1],orientation[12],positionLM[13][0],positionLM[13][1],orientation[13],positionLM[14][0],positionLM[14][1],orientation[14],positionLM[15][0],positionLM[15][1],orientation[15],positionLM[16][0],positionLM[16][1],orientation[16],positionLM[17][0],positionLM[17][1],orientation[17],positionLM[18][0],positionLM[18][1],orientation[18],positionLM[19][0],positionLM[19][1],orientation[19],positionLM[20][0],positionLM[20][1],orientation[20],positionLM[21][0],positionLM[21][1],orientation[21],positionLM[22][0],positionLM[22][1],orientation[22],positionLM[23][0],positionLM[23][1],orientation[23],positionLM[24][0],positionLM[24][1],orientation[24],positionLM[25][0],positionLM[25][1],orientation[25],positionLM[26][0],positionLM[26][1],orientation[26],positionLM[27][0],positionLM[27][1],orientation[27],positionLM[28][0],positionLM[28][1],orientation[28],positionLM[29][0],positionLM[29][1],orientation[29],positionLM[30][0],positionLM[30][1],orientation[30],positionLM[31][0],positionLM[31][1],orientation[31],positionLM[32][0],positionLM[32][1],orientation[32],positionLM[33][0],positionLM[33][1],orientation[33],positionLM[34][0],positionLM[34][1],orientation[34],positionLM[35][0],positionLM[35][1],orientation[35],positionLM[36][0],positionLM[36][1],orientation[36],positionLM[37][0],positionLM[37][1],orientation[37],positionLM[38][0],positionLM[38][1],orientation[38],positionLM[39][0],positionLM[39][1],orientation[39],positionLM[40][0],positionLM[40][1],orientation[40],positionLM[41][0],positionLM[41][1],orientation[41],positionLM[42][0],positionLM[42][1],orientation[42],positionLM[43][0],positionLM[43][1],orientation[43],positionLM[44][0],positionLM[44][1],orientation[44],positionLM[45][0],positionLM[45][1],orientation[45],positionLM[46][0],positionLM[46][1],orientation[46],positionLM[47][0],positionLM[47][1],orientation[47],positionLM[48][0],positionLM[48][1],orientation[48],positionLM[49][0],positionLM[49][1],orientation[49],no_of_collisions,average_trip_delay,no_of_vehicles_crossed,vehicleID}
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>
